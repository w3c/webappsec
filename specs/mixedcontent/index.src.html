<h1>Mixed Content</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/mixedcontent/
Shortname: mixed-content
TR: http://www.w3.org/TR/mixed-content/
Previous Version: http://www.w3.org/TR/2015/CR-mixed-content-20150317/
Previous Version: http://www.w3.org/TR/2014/WD-mixed-content-20141113/
Previous Version: http://www.w3.org/TR/2014/WD-mixed-content-20140916/
Previous Version: http://www.w3.org/TR/2014/WD-mixed-content-20140722/
Level: 1
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This specification describes how a user agent should handle fetching of
  content over unencrypted or unauthenticated connections in the context of an
  encrypted and authenticated document.
Version History: https://github.com/w3c/webappsec/commits/master/specs/mixedcontent/index.src.html
Indent: 2
</pre>
<!--
   ███    ██    ██  ██████  ██     ██  ███████  ████████   ██████ 
  ██ ██   ███   ██ ██    ██ ██     ██ ██     ██ ██     ██ ██    ██
 ██   ██  ████  ██ ██       ██     ██ ██     ██ ██     ██ ██      
██     ██ ██ ██ ██ ██       █████████ ██     ██ ████████   ██████ 
█████████ ██  ████ ██       ██     ██ ██     ██ ██   ██         ██
██     ██ ██   ███ ██    ██ ██     ██ ██     ██ ██    ██  ██    ██
██     ██ ██    ██  ██████  ██     ██  ███████  ██     ██  ██████ 
-->
<!--
    HTML Definitions
-->
<pre class="anchors">
type: dfn
  urlPrefix: https://tools.ietf.org/html/rfc6797
    text: mixed security context; url: section-12.4
type: dfn
  urlPrefix: http://www.w3.org/TR/html5/; spec: HTML5
    urlPrefix: embedded-content-0.html
      text: an iframe srcdoc document
    urlPrefix: browsers.html
      text: browsing context
      text: browsing context container
      text: child browsing context
      text: creating a new Document object; url: create-a-document-object
      text: navigated; url: navigate
      text: nested browsing context
      text: nested through; url: browsing-context-nested-through
      text: plugin document
      text: sandboxed origin browsing context flag
      text: sandboxing flag set
      text: top-level browsing context; url: top-level-browsing-context
    urlPrefix: infrastructure.html
      text: plugin
      text: reflect
    urlPrefix: webappapis.html
      text: environment settings object; url: settings-object
      text: incumbent settings object
      text: relevant settings object for a script
      text: responsible document
      text: global object
  urlPrefix: https://w3c.github.io/webappsec/specs/content-security-policy/; spec: CSP2
    text: enforce
    text: monitor
  urlPrefix: https://tools.ietf.org/html/rfc6454; spec: RFC6454
    text: origin; url: section-3.2
    text: globally unique identifier; url: section-2.3
  urlPrefix: https://fetch.spec.whatwg.org/; spec: FETCH
    text: fetching
    text: request; url: concept-request
    text: response; url: concept-response
    text: network error; url: concept-network-error
    text: opaque filtered response; url: concept-filtered-response-opaque
    url: concept-request-client
      text: request client
      text: client
    url: concept-request-context
      text: request context
      text: context
    url: concept-request-context-frame-type
      text: request context frame type
      text: frame type
    url: concept-response-https-state
      text: response https state;
      text: https state
  urlPrefix: https://tools.ietf.org/html/rfc6455; spec: RFC6455
    text: fail the websocket connection; url: section-7.1.7
type: method
  text: Fetch; for: GlobalFetch; url: https://fetch.spec.whatwg.org/#dom-global-fetch
type: attribute
  text: onerror; for: WebSocket; url: http://www.w3.org/TR/websockets/#handler-websocket-onerror
type: interface
  text: WebSocket; url: http://www.w3.org/TR/websockets/#the-websocket-interface
  text: XMLHttpRequest; url: http://www.w3.org/TR/XMLHttpRequest/#interface-xmlhttprequest
  text: EventSource; url: http://www.w3.org/TR/eventsource/#the-eventsource-interface
  text: Document; url: http://www.w3.org/TR/html5/dom.html#document
  text: Window; url: http://www.w3.org/TR/html5/browsers.html#window
  text: ServiceWorkerGlobalScope; url: http://www.w3.org/TR/service-workers/#service-worker-global-scope
type: element
  urlPrefix: http://www.w3.org/TR/html5/; spec: HTML5
    urlPrefix: document-metadata.html
      text: meta; url: the-meta-element
    urlPrefix: forms.html
      text: form; url: the-form-element
    urlPrefix: embedded-content-0.html
      text: audio; url: the-audio-element
      text: iframe; url: the-iframe-element
      text: img; url: the-img-element
      text: video; url: the-video-element
      text: source; url: the-source-element
      text: track; url: the-track-element
    urlPrefix: scripting-1.html
      text: script; url: the-script-element
    urlPrefix: obsolete.html
      text: frame
type: element-attr
  urlPrefix: http://www.w3.org/TR/html5/; spec: HTML5
    urlPrefix: forms.html
      text: action; for: form; url: attr-fs-action
    urlPrefix: embedded-content-0.html
      text: sandbox; for: iframe; url: attr-iframe-sandbox
</pre>

<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  When a user successfully loads a resource from example.com over a secure
  channel (HTTPS, for example), the user agent is able to make three assertions
  critical to the user's security and privacy:

  <ul>
    <li>
      The user is communicating with a server that is allowed to claim to be
      <code>example.com</code>, and not one of the many, many servers through
      which her request has hopped. The connection can be
      <strong>authenticated</strong>.
    </li>
    <li>
      The user's communications with <code>example.com</code> cannot be
      trivially eavesdropped upon by middlemen, because the requests she makes
      and the responses she receives are <strong>encrypted</strong>.
    </li>
    <li>
      The user's communications with <code>example.com</code> cannot be
      trivially modified by middlemen, the encryption and authentication
      provide a guarantee of <strong>data integrity</strong>.
    </li>
  </ul>

  Together, these assertions give the user some assurance that
  <code>example.com</code> is the only entity that can read and respond to her
  requests (caveat: without shocking amounts of work) and that the bits she's
  received are indeed those that <code>example.com</code> actually sent.

  The strength of these assertions is substantially weakened, however, when
  the encrypted and authenticated resource requests subresources (scripts,
  images, etc) over an insecure channel. Those resource requests result in a
  resource whose status is mixed, as insecure requests are wide open for
  man-in-the-middle attacks. This scenario is unfortunately quite common.

  This specification details how a user agent can mitigate these risks to
  security and privacy by limiting a resource's ability to inadvertently
  communicate in the clear.

  Note: Nothing described in this document is really new; everything covered
  here has appeared in one or more user agents over the years: Internet
  Explorer led the way, alerting users to mixed content since
  <a href="https://twitter.com/ericlaw/status/469813922908758016">around</a>
  <a href="https://support2.microsoft.com/default.aspx?scid=kb;EN-US;Q261188">version 4</a>.
</section>

<!--
████████  ████████ ████████ ████ ██    ██ ████ ████████ ████  ███████  ██    ██  ██████
██     ██ ██       ██        ██  ███   ██  ██     ██     ██  ██     ██ ███   ██ ██    ██
██     ██ ██       ██        ██  ████  ██  ██     ██     ██  ██     ██ ████  ██ ██
██     ██ ██████   ██████    ██  ██ ██ ██  ██     ██     ██  ██     ██ ██ ██ ██  ██████
██     ██ ██       ██        ██  ██  ████  ██     ██     ██  ██     ██ ██  ████       ██
██     ██ ██       ██        ██  ██   ███  ██     ██     ██  ██     ██ ██   ███ ██    ██
████████  ████████ ██       ████ ██    ██ ████    ██    ████  ███████  ██    ██  ██████
-->
<section>
  <h2 id="terms">Key Concepts and Terminology</h2>

  <dl>
    <dt>
      <dfn export local-lt="mixed">mixed content</dfn>
    </dt>
    <dd>
      A resource or <a>request</a> is <strong>mixed content</strong> if its
      <a>origin</a> is <a>insecure</a>, <strong>and</strong> the context
      responsible for loading it restricts mixed content. See
      [[#categorize-settings-object]] for a normative definition of the latter.

      <div class="example">
        Inside a context that restricts mixed content
        (<code>https://secure.example.com/</code>, for example):

        1.  A request for the script <code>http://example.com/script.js</code>
            is <strong>mixed content</strong>. As script <a>requests</a> are
            <a>blockable</a>, the user agent will return a network error rather
            than loading the resource.

        2.  A request for the image <code>http://example.com/image.png</code> is
            <strong>mixed content</strong>. As image <a>requests</a> are
            <a>optionally-blockable</a>, the user agent might load the image, in
            which case the image resource itself would be <strong>mixed
            content</strong>.
      </div>

      If mixed content is loaded into a context that restricts mixed content
      (as in #2 above), that context is considered a <a>mixed security
      context</a> (as defined in [[!RFC6797]]).

      Note: "Mixed content" was originally defined in
      <a href="http://www.w3.org/TR/wsc-ui/#securepage">section 5.3</a> of
      [[WSC-UI]]. This document updates that initial definition.

      Note: [[XML]] also defines an unrelated 
      <a href="http://www.w3.org/TR/2008/REC-xml-20081126/#sec-mixed-content">"mixed content"</a>.
      concept. This is potentially confusing, but given the term's near
      ubiquitious usage in a security context across user agents for more than
      a decade, the practical risk of confusion seems low.
    </dd>

    <dt>
      <dfn export local-lt="potentially secure">
        potentially secure origin
      </dfn>
    </dt>
    <dt>
      <dfn export>
        potentially secure URL
      </dfn>
    </dt>
    <dd>
      An <a>origin</a> is said to be <strong>potentially secure</strong>
      if the origin's scheme component is <code>HTTPS</code>, <code>WSS</code>,
      or <code>about</code>.

      A URL whose <a>origin</a> is potentially secure is itself considered to
      be potentially secure.
    </dd>

    <dt>
      <dfn export local-lt="a priori insecure">
        <i lang="la">a priori</i> insecure origin
      </dfn>
    </dt>
    <dt>
      <dfn export>
        <i lang="la">a priori</i> insecure URL
      </dfn>
    </dt>
    <dd>
      Any <a>origin</a> which is not <a>potentially secure</a> is said to
      be <strong><i lang="la">a priori</i> insecure</strong>. We know, for
      example, that <code>(http, example.com, 80)</code> is insecure just by
      looking at its scheme component.

      A URL whose <a>origin</a> is <i lang="la">a priori</i> insecure is itself
      considered to be <i lang="la">a priori</i> insecure.
    </dd>

    <dt>
      <dfn export local-lt="insecure">
        insecure origin
      </dfn>
    </dt>
    <dt>
      <dfn export>
        insecure URL
      </dfn>
    </dt>
    <dd>
      A resource's origin is said to be <strong>insecure</strong> if it is
      either <a><i lang="la">a priori</i> insecure</a>, or the user agent discovers
      only after performing a TLS-handshake that the <a>Response</a>'s <a>HTTPS
      state</a> is <code>deprecated authentication</code>.

      A URL whose <a>origin</a> is insecure is itself considered to be insecure.
    </dd>

    <dt><dfn export>embedding document</dfn></dt>
    <dd>
      Given a {{Document}} <var>A</var>, the <strong>embedding
      document</strong> of <var>A</var> is the {{Document}}
      <a lt="nested through">through which</a> <var>A</var>'s <a>browsing
      context</a> is nested.
    </dd>
  </dl>
</section>

<!--
 ██████     ███    ████████ ████████  ██████    ███████  ████████  ████ ████████  ██████ 
██    ██   ██ ██      ██    ██       ██    ██  ██     ██ ██     ██  ██  ██       ██    ██
██        ██   ██     ██    ██       ██        ██     ██ ██     ██  ██  ██       ██      
██       ██     ██    ██    ██████   ██   ████ ██     ██ ████████   ██  ██████    ██████ 
██       █████████    ██    ██       ██    ██  ██     ██ ██   ██    ██  ██             ██
██    ██ ██     ██    ██    ██       ██    ██  ██     ██ ██    ██   ██  ██       ██    ██
 ██████  ██     ██    ██    ████████  ██████    ███████  ██     ██ ████ ████████  ██████ 
-->
<section>
  <h2 id="categories">Content Categories</h2>

  In a perfect world, each user agent would be required to block all <a>mixed
  content</a> without exception. Unfortunately, that is impractical on today's
  Internet; a user agent needs to be more nuanced in its restrictions to avoid
  degrading the experience on a substantial number of websites.

  With that in mind, we here split mixed content into two categories:
  [[#category-optionally-blockable]] and [[#category-blockable]].

  Note: Future versions of this specification will update this categorization
  with the intent of moving towards a world where all <a>mixed</a> content is
  blocked; that is the end goal, but this is the best we can do for now.

  <section>
    <h3 id="category-optionally-blockable">Optionally-blockable Content</h3>

    A resource or <a>request</a> is <dfn>optionally-blockable</dfn>
    when the risk of allowing its usage as <a>mixed content</a> is outweighed by
    the risk of breaking significant portions of the web. This could be because
    mixed usage of the resource type is sufficiently high, and because the
    resource is low-risk in and of itself. The fact that these resource types
    are optionally-blockable does not mean that they are <em>safe</em>, simply
    that they're less catastrophically dangerous than other resource types. For
    example, images and icons are often the central UI elements in an
    application's interface. If an attacker reversed the "Delete email" and
    "Reply" icons, there would be real impact to users.

    This category of content includes:

    <ul>
      <li>
        Images loaded via <a element>img</a>

        Note: This includes SVG documents loaded as images, as they are banned from
        executing script or loading subresources.
      </li>
      <li>
        Video loaded via <a element>video</a> and <a element>source</a>
      </li>
      <li>
        Audio loaded via <a element>audio</a> and <a element>source</a>
      </li>
      <li>
        <a href="http://www.w3.org/TR/html5/links.html#link-type-prefetch">Prefetched</a>
        content [[!HTML5]]
      </li>
    </ul>

    These resource types map to the following Fetch <a>request contexts</a>:
    <code>audio</code>, <code>image</code>, <code>prefetch</code>, and
    <code>video</code>. These contexts are <dfn>optionally-blockable request
    contexts</dfn>.

    Note: We further limit this category in [[#should-block-fetch]] by
    force-failing any CORS-enabled request. This means that mixed content images
    loaded via <code>&lt;img crossorigin ...&gt;</code> will be blocked. This is
    a good example of the general principle that a category of content falls
    into this category <em>only</em> when it is too widely used to be blocked
    outright. The Working Group intends to find more blockable subsets of an
    otherwise <a>optionally-blockable request context</a>.
  </section>

  <section>
    <h3 id="category-blockable">Blockable Content</h3>

    Any resource or <a>request</a> that isn't <a>optionally-blockable</a> is
    <dfn>blockable</dfn>. Typical examples of this kind of content include scripts,
    <a>plugin</a> data, data requested via {{XMLHttpRequest}}, and so on. Every
    <a>request context</a> that is not <a>optionally-blockable</a> is a
    <dfn>blockable request context</dfn>. This explicitly includes any contexts
    defined after publication of this document.

    Note: The request contexts <code>form</code>, <code>hyperlink</code>, and
    <code>location</code> might refer to <a>top-level browsing context</a>
    <a lt="navigated">navigations</a>, which are not considered mixed
    content. See the treatment of <a>request context frame type</a> in
    [[#should-block-fetch]] for details.

    Note: The <code>plugin</code> request context is used for requests made on
    behalf of a plugin. We categorize these requests as blockable, but recognize
    that user agents aren't always in a position to mediate these requests.
    NPAPI plugins, for instance, often have direct network access, and can
    generally bypass the user agent entirely. We recommend that plugin vendors
    implement mixed content checking themselves to mitigate the risks outlined
    in this document.
  </section>
</section>

<!-- Big Text: strict mode -->
<section>
  <h2 id="strict-checking">Strict Mixed Content Checking</h2>

  In order to give authors assurance that mixed content will never degrade the
  security UI presented to their users (as described in [[#requirements-ux]]),
  authors may choose to enable a stricter variant of mixed content checking
  which will both block <a>optionally-blockable</a> and <a>blockable</a> mixed
  content, and suppress the user override options discussed in
  [[#requirements-user-controls]].

  To this end, {{Document}} objects and <a>browsing contexts</a> have a
  <dfn>strict mixed content checking flag</dfn> which is set to
  <code>false</code> unless otherwise specified. This flag is checked in both
  [[#should-block-fetch]] and [[#should-block-response]] to determine whether
  the {{Document}} is in <dfn>strict mode</dfn>.

  <div class="example">
    A {{Document}} may opt itself into strict mode by either delivering a
    <code>Content-Security-Policy</code> HTTP header, like:

    <pre>
      Content-Security-Policy: <a>block-all-mixed-content</a>
    </pre>

    or by embedding the policy in a <a element>meta</a> element, like:

    <pre>
      &lt;meta http-equiv="Content-Security-Policy"
            content="<a>block-all-mixed-content</a>"&gt;
    </pre>
  </div>

  Note: Strict mixed content checking is inherited by embedded content; if
  a page opts into strict mode, framed pages will be prevented from loading
  mixed content, as described in [[#strict-nesting]].

  <h3 id="strict-effects">Effects</h3>

  If a {{Document}}'s <a>strict mixed content checking flag</a> is set to
  <code>true</code>, the user agent MUST:

  <ol>
    <li>
      treat <a>optionally-blockable</a> mixed content as though it were
      <a>blockable</a>.
    </li>
    <li>
      NOT provide users with a mechanism for forcing <a>blockable</a>
      mixed content to load.

      Note: This requirement overrides the suggestion in
      [[#requirements-user-controls]].
    </li>
    <li>
      NOT provide any user-facing indication that mixed content is present.

      Note: This requirement overrides the suggestion in [[#requirements-ux]],
      which is safe to do since the combination of the first and second
      requirements above ensure that mixed content will never load in this
      page's context.

      Note: This requirement does not include developer-facing indicators such
      as console messages.
    </li>
    <li>
      ensure that these requirements are applied to any {{Document}} in a
      <a>nested browsing context</a>, as described in [[#strict-nesting]].
    </li>
  </ol>
  
  <h3 id="strict-opt-in">Opting-in</h3>

  Authors may opt a {{Document}} into strict mixed content checking via a
  <dfn>block-all-mixed-content</dfn> Content Security Policy directive
  [[!CSP2]], defined via the following ABNF grammar.

  <pre>
    directive-name  = "block-all-mixed-content"
    directive-value = ""
  </pre>

  When <a>enforcing</a> the <code>block-all-mixed-content</code> directive,
  set the protected resource's <a>strict mixed content checking flag</a> to
  <code>true</code>.

  This directive has no effect when <a>monitored</a>. This directive's only
  effect is to set a policy flag on the protected resource; it will therefore
  never be violated, and has no reporting requirements. 

  Note: A similar effect may be achieved on a more granular level by setting
  individual directives. For example <code>img-src https:</code> would prevent
  insecure images from loading.

  <h3 id="strict-nesting">Inheriting an opt-in</h3>

  If a {{Document}}'s <a>strict mixed content checking flag</a> is set, the user
  agent MUST ensure that all <a>nested browsing contexts</a> inherit the setting
  in the following ways:

  <ol>
    <li>
      When a <a>nested browsing context</a> <var>context</var> is created, set
      its <a>strict mixed content checking flag</a> to <code>true</code> if 
      <var>context</var>'s <a>embedding document</a>'s <a>strict mixed content
      checking flag</a> is set to <code>true</code>.
    </li>
    <li>
      When <a>creating a new <code>Document</code> object</a>, set its <a>strict
      mixed content checking flag</a> to <code>true</code> if its <a>browsing
      context</a>'s <a>strict mixed content checking flag</a> is
      <code>true</code>.
    </li>
  </ol>
</section>

<!--
   ███    ██        ██████    ███████  ████████  ████ ████████ ██     ██ ██     ██  ██████
  ██ ██   ██       ██    ██  ██     ██ ██     ██  ██     ██    ██     ██ ███   ███ ██    ██
 ██   ██  ██       ██        ██     ██ ██     ██  ██     ██    ██     ██ ████ ████ ██
██     ██ ██       ██   ████ ██     ██ ████████   ██     ██    █████████ ██ ███ ██  ██████
█████████ ██       ██    ██  ██     ██ ██   ██    ██     ██    ██     ██ ██     ██       ██
██     ██ ██       ██    ██  ██     ██ ██    ██   ██     ██    ██     ██ ██     ██ ██    ██
██     ██ ████████  ██████    ███████  ██     ██ ████    ██    ██     ██ ██     ██  ██████
-->
<section>
  <h2 id="algorithms">Insecure Content in Secure Contexts</h2>

  At a high level, the following algorithms allow user agents to determine
  whether particular requests should succeed, or should result in network
  errors.

  Fetch calls the algorithm defined in
  [[#should-block-fetch]] during
  <a href="https://fetch.spec.whatwg.org/#fetching">Step 4 of the Fetching
  algorithm</a> [[!FETCH]] in order to block network traffic to <a><em>a
  priori</em> insecure origins</a>.

  Note: Hooking into Fetch here ensures that we catch not only the initial
  request, but all redirects as well.

  Further, Fetch calls the algorithm defined in
  [[#should-block-response]] during
  <a href="https://fetch.spec.whatwg.org/#fetching">Step 7 of the Fetching
  algorithm</a> [[!FETCH]] in order to block responses from <a>insecure
  origins</a>.

  Note: This hook is necessary to detect resources modified or
  synthesized by a ServiceWorker, as well as to determine whether a
  resource is <a>insecure</a> once the TLS-handshake has finished. See
  steps 4.1 and 4.2 of the algorithm defined in [[#should-block-response]] for
  detail.

  The algorithm defined in [[#categorize-settings-object]] is used by both
  [[#should-block-fetch]] and [[#should-block-response]], as well as
  [[#websockets-integration]] in order to determine whether an insecure request
  ought to be blocked.

  <section>
    <h3 id="categorize-settings-object">
      Does <var>settings object</var> restrict mixed content?
    </h3>

    Both documents and workers have <a>environment settings objects</a> which
    may be examined according to the following algorithm in order to determine
    whether they restrict mixed content. This algorithm returns <code>Restricts
    Mixed Content</code> or <code>Does Not Restrict Mixed Content</code>, as
    appropriate.

    Given an <a>environment settings object</a> <var>settings</var>:

    <ol>
      <li>
        If <var>settings</var>' <a>HTTPS state</a> is not
        <code>unauthenticated</code>, then return <strong>Restricts Mixed
        Content</strong>.
      </li>
      <li>
        If <var>settings</var> has a <a>responsible document</a>
        <var>document</var>, then:

        <ol>
          <li>
            While <var>document</var> has an <a>embedding document</a>:

            <ol>
              <li>
                Let <var>document</var> be <var>document</var>'s <a>embedding
                document</a>.
              </li>
              <li>
                Let <var>embedder settings</var> be <var>document</var>'s
                <var>incumbent settings object</var>.
              </li>
              <li>
                If <var>embedder settings</var>' <a>HTTPS state</a> is not
                <code>unauthenticated</code>, then return <strong>Restricts
                mixed content</strong>.
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Return <strong>Does Not Restrict Mixed Content</strong>.</li>
    </ol>

    <div class="note">
      If a document has an <a>embedding document</a>, a user agent needs to
      check not only the document itself, but also the <a>top-level browsing
      context</a> in which the document is nested, as that is the context
      which controls the user's expectations regarding the security status of
      the resource she's loaded. For example:

      <div class="example">
        <code>http://a.com</code> loads <code>http://evil.com</code>. The
        insecure request will be allowed, as <code>a.com</code> was not loaded
        over a secure connection.
      </div>

      <div class="example">
        <code>https://a.com</code> loads <code>http://evil.com</code>. The
        insecure request will be blocked, as <code>a.com</code> was loaded over
        a secure connection.
      </div>

      <div class="example">
        <code>http://a.com</code> frames <code>https://b.com</code>, which
        loads <code>http://evil.com</code>. In this case, the insecure request
        to <code>evil.com</code> will be blocked, as <code>b.com</code> was
        loaded over a secure connection, even though <code>a.com</code> was not.
      </div>

      <div class="example">
        <code>https://a.com</code> frames a <code>data:</code> URL, which loads
        <code>http://evil.com</code>. In this case, the insecure request to
        <code>evil.com</code> will be blocked, as <code>a.com</code> was loaded
        over a secure connection, even though the framed <code>data:</code> URL
        is <a><i lang="la">a priori</i> insecure</a>.
      </div>
    </div>
  </section>

  <section>
    <h3 id="is-passthrough">
      Is <var>request</var> a passthrough request?
    </h3>

    A <dfn>passthrough request</dfn> is a <a>request</a> (<var>request</var>)
    which is created in a <a>browsing context</a> (e.g. via an <{img}> tag in a
    document), but serviced by a Service Worker (e.g. by calling
    <code>fetch(e.request)</code> from within an <code>onfetch</code> event
    handler). As described in [[#service-workers]], we special-case these kinds
    of requests in order to allow web developers to layer service workers on top
    of an existing site which relies on requesting <a>optionally-blockable</a>
    mixed content.

    More formally, <var>request</var> is a passthrough request if the following
    conditions hold:

    <ol>
      <li>
        <var>request</var>'s <code>context</code> is <code>fetch</code>

        Note: When a request is copied (as in the <code>fetch(e.response)</code>
        example above), the original <code>context</code> is lost. Here, we
        ensure that we're dealing with such a request, but we implicitly rely on
        [[#should-block-fetch]] preventing <a>blockable</a> requests from
        entering a Service Worker in the first place.
      </li>
      <li>
        <var>request</var>'s <code>window</code> is an <a>environment settings
        object</a> (and, therefore, <strong>not</strong> <code>no-window</code>)

        Note: We rely on the <code>window</code> property being properly set by
        [[FETCH]] to the <a>environment settings object</a> responsible for the
        request in order to ensure that we can render some sort of warning to
        the user (as described in [[#requirements-ux]]).
      </li>
      <li>
        <var>request</var>'s <code>client</code>'s <a>global object</a> is a
        {{ServiceWorkerGlobalScope}} object.

        Note: We rely on the <code>client</code> property to reflect the origin
        of the request. Importantly, <var>request</var> is only a passthrough
        request if it originated inside a Service Worker.
      </li>
    </ol>
  </section>

  <section>
    <h3 id="should-block-fetch">
      Should fetching <var>request</var> be blocked as mixed content?
    </h3>

    Note: The Fetch specification hooks into this algorithm to determine whether
    a request should be entirely blocked (e.g. because the request is for
    <a>blockable</a> content, and we can <em>assume</em> that it won't be
    loaded over a secure connection).

    Given a <a>Request</a> <var>request</var>, a user agent determines
    whether the <a>Request</a> <var>request</var> should proceed or not via the
    following algorithm:

    <ol>
      <li>
        Let <var>context</var> be <var>request</var>'s <code>context</code>.
      </li>
      <li>
        Let <var>frame type</var> be <var>request</var>'s <code>context frame
        type</code>.
      </li>
      <li>
        Let <var>origin</var> be the <a>origin</a> of <var>request</var>'s
        <strong>URL</strong>.
      </li>
      <li>
        If [[#categorize-settings-object]] returns <code>Does Not Restrict
        Mixed Content</code> when applied to <var>request</var>'s <a>client</a>,
        return <strong>allowed</strong>.
      </li>
      <li>
        If the user agent has been instructed to allow <a>mixed content</a>
        (as outlined in [[#requirements-user-controls]]), return
        <strong>allowed</strong>.
      </li>
      <li>
        If <var>request</var>'s <code>context frame type</code> is
        <code>top-level</code>, return <strong>allowed</strong>.
      </li>
      <li>
        If <var>origin</var> is <a><i lang="la">a priori</i> insecure</a>:

        <ol>
          <li>
            If <var>request</var>'s <code>mode</code> is <code>CORS</code> or
            <code>CORS-with-forced-preflight</code>, return
            <strong>blocked</strong>.
          </li>
          <li>
            If <var>context</var> is <code>fetch</code>:

            <ol>
              <li>
                If <var>request</var> is <strong>not</strong> a <a>passthrough
                request</a>, return <strong>blocked</strong>.
              </li>
              <li>
                If <var>request</var>'s <code>mode</code> is not
                <code>no-cors</code>, return <strong>blocked</strong>.
              </li>
            </ol>
          <li>
            Otherwise, if <var>context</var> is a <a>blockable request
            context</a>, return <strong>blocked</strong>.
          </li>
          <li>
            If the user agent is configured to block <a>optionally-blockable</a>
            mixed content, return <strong>blocked</strong>.
          </li>
          <li>
            If <var>request</var>'s <a>client</a>'s <a>strict mixed content
            checking flag</a> is <code>true</code>, return
            <strong>blocked</strong>.
          </li>
        </ol>
      </li>
      <li>
        Return <strong>allowed</strong>.
      </li>
    </ol>

    Note: We special-case <code>fetch</code> to allow it as optionally-blockable
    in the event that a Service Worker is making a <code>no-cors</code> request
    in response to a Fetch event generated from a Document. In that case, the
    request's <code>client</code> property will be an <a>environment settings
    object</a> whose global object is a {{Window}} object (the Service Worker's
    request's <code>client</code>, on the other hand, will be a
    <code>WorkerGlobalScope</code> object.
  </section>

  <section>
    <h3 id="should-block-response">
      Should <var>response</var> to <var>request</var> be blocked as mixed
      content?
    </h3>

    Note: <a href="#should-block-fetch">If a request proceeds</a>, we still
    might want to block the response based on the state of the connection
    that generated the response (e.g. because the request is <a>blockable</a>,
    but the connection is <a>insecure</a>), and we also need to ensure that
    Service Worker doesn't accidentally return an <a>insecure</a> response
    for a <a>blockable</a> request. This algorithm is used to make that
    determination.

    Given a <a>request</a> <var>request</var> and <a>response</a>
    <var>response</var>, the user agent determines what response should be
    returned via the following algorithm:

    <ol>
      <li>
        If [[#categorize-settings-object]] returns <code>Does Not Restrict
        Mixed Content</code> when applied to <var>request</var>'s <a>client</a>,
        return <strong>allowed</strong>.
      </li>
      <li>
        If the user agent has been instructed to allow <a>mixed content</a>
        (as outlined in [[#requirements-user-controls]]), return
        <strong>allowed</strong>.
      </li>
      <li>
        Let <var>context</var> be the <a>request context</a> of
        <var>request</var>.
      </li>
      <li>
        If <var>response</var>'s <a>HTTPS state</a> is not
        <code>authenticated</code>:

        <ol>
          <li>
            If <var>context</var> is <code>fetch</code>:

            <ol>
              <li>
                If <var>request</var> is <strong>not</strong> a <a>passthrough
                request</a>, return <strong>blocked</strong>.
              </li>
              <li>
                If <var>response</var> is <strong>not</strong> an <a>opaque
                filtered response</a>, return <strong>blocked</strong>.
              </li>
              <li>
                If the user agent is configured to block
                <a>optionally-blockable</a> mixed content, return
                <strong>blocked</strong>.
              </li>
              <li>
                If <var>request</var>'s <a>client</a>'s <a>strict mixed content
                checking flag</a> is <code>true</code>, return
                <strong>blocked</strong>.
              </li>
            </ol>
          </li>
          <li>
            Otherwise:

            <ol>
              <li>
                If <var>context</var> is a <a>blockable request
                context</a>, return <strong>blocked</strong>.
              </li>
              <li>
                If the user agent is configured to block
                <a>optionally-blockable</a> mixed content, return
                <strong>blocked</strong>.
              </li>
              <li>
                If <var>request</var>'s <a>client</a>'s <a>strict mixed content
                checking flag</a> is <code>true</code>, return
                <strong>blocked</strong>.
              </li>
            </ol>
          </li>
        </ol>

        Note: This covers both cases in which unauthenticated resources are
        returned (by a Service Worker, for example), as well as cases in
        which the TLS handshake succeeds, but the user agent chooses to hold
        it to a higher standard.
      </li>
      <li>Return <strong>allowed</strong>.</li>
    </ol>
  </section>
</section>

<!--
██      ██ ████████ ████████   ██████   ███████   ██████  ██    ██ ████████ ████████  ██████
██  ██  ██ ██       ██     ██ ██    ██ ██     ██ ██    ██ ██   ██  ██          ██    ██    ██
██  ██  ██ ██       ██     ██ ██       ██     ██ ██       ██  ██   ██          ██    ██
██  ██  ██ ██████   ████████   ██████  ██     ██ ██       █████    ██████      ██     ██████
██  ██  ██ ██       ██     ██       ██ ██     ██ ██       ██  ██   ██          ██          ██
██  ██  ██ ██       ██     ██ ██    ██ ██     ██ ██    ██ ██   ██  ██          ██    ██    ██
 ███  ███  ████████ ████████   ██████   ███████   ██████  ██    ██ ████████    ██     ██████
-->
<section>
  <h2 id="websockets-integration">Modifications to WebSockets</h2>

  The <a href="http://www.w3.org/TR/websockets/#the-websocket-interface"><code>WebSocket()</code>
  constructor algorithm</a> [[!WEBSOCKETS]] is modified as follows:

  <ul>
    <li>
      Remove the current step 2.
    </li>
  </ul>

  Note: This suggestion is filed as
  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28841">bug #28841</a>
  against [[WEBSOCKETS]].

  The <a href="http://tools.ietf.org/html/rfc6455#section-4.1">Establish a
  WebSocket Connection algorithm</a> [[!RFC6455]] is modified as follows:

  <ul>
    <li>
      After the current step 1, perform the following step:

      <ol>
        <li>
          If <var>secure</var> is <strong>false</strong>, and the algorithm in
          [[#categorize-settings-object]] returns <code>Restricts Mixed
          Content</code> when applied to <var>client</var>'s <var>entry
          script</var>'s
          <a lt="relevant settings object for a script">relevant settings
          object</a>'s, then the client MUST <a>fail the WebSocket
          connection</a> and abort the connection [[!RFC6455]].
        </li>
      </ol>
    </li>
    <li>
      After the current step 5, perform the following step:

      <ol>
        <li>
          If secure is <strong>true</strong>, and the TLS handshake performed
          in step 5 results in <code>deprecated authentication</code>,
          then the client MUST <a>fail the WebSocket connection</a> and abort
          the connection [[!RFC6455]].

          ISSUE: This is super hand-wavey.
        </li>
      </ol>
    </li>
  </ul>

  Note: Filed as
  <a href="http://www.rfc-editor.org/errata_search.php?rfc=6455&eid=4398">errata #4398</a>
  against [[RFC6455]].

  These changes together mean that we'll no longer throw a
  <code>SecurityError</code> exception directly upon constructing a WebSocket
  object, but will instead rely upon blocking the connection and triggering the
  <a>fail the WebSocket connection</a> algorithm, which developers can catch by
  hooking a {{WebSocket}} object's {{WebSocket/onerror}} handler. This is
  consistent with the behavior of {{XMLHttpRequest}}, {{EventSource}}, and
  {{Fetch}}.
</section>

<!--
 ██████  ████████  ██████  ██     ██ ████████  ████ ████████ ██    ██
██    ██ ██       ██    ██ ██     ██ ██     ██  ██     ██     ██  ██ 
██       ██       ██       ██     ██ ██     ██  ██     ██      ████  
 ██████  ██████   ██       ██     ██ ████████   ██     ██       ██   
      ██ ██       ██       ██     ██ ██   ██    ██     ██       ██   
██    ██ ██       ██    ██ ██     ██ ██    ██   ██     ██       ██   
 ██████  ████████  ██████   ███████  ██     ██ ████    ██       ██   
-->
<section>
  <h2 id="security-considerations">Security Considerations</h2>

  <section>
    <h3 id="limitations">Limitations</h3>

    Blocking mixed content allows us to ensure that the guarantees discussed
    in [[#intro]] are upheld. Note, however, that those guarantees <em>only</em>
    protect developers and users against active network attackers who would
    otherwise be able to replace critical bits of code or content on the wire
    as it flows past. They <em>do not</em> protect against a compromised server
    that itself is coerced into sending corrupted resources.

    Mechanisms such as Subresource Integrity [[SRI]] are designed to deal with
    this kind of threat, and we recommend that web developers make use of them
    whenever possible.
  </section>

  <section>
    <h3 id="requirements-forms">Form Submission</h3>

    If [[#categorize-settings-object]] returns <code>Restricts Mixed
    Content</code> when applied to a {{Document}}'s <a>incumbent settings
    object</a>, then a user agent MAY choose to warn users of the presence of
    one or more <a element>form</a> elements with <a element-attr>action</a>
    attributes whose values are <a>insecure URLs</a>.

    Note: Chrome, for example, currently gives the same UI treatment to a page
    with an insecure form action as it does for a page that displays an insecure
    image.

    Further, a user agent MAY treat form submissions from such a {{Document}}
    as a <a>blockable</a> request, even if the submission occurs in
    the <a>top-level browsing context</a>.
  </section>

  <section>
    <h3 id="requirements-ux">UI Requirements</h3>

    If a user agent would normally indicate to the user that the
    <a>top-level browsing context</a> is secure, then:
   
    *   When the user agent downgrades a context to a <a>mixed security
        context</a> by returning a resource in response to a <a>mixed
        content</a> <a>request</a> (either because the <a>request</a> is
        <a>optionally-blockable</a>, or because the user agent is configured
        to allow <a>blockable</a> <a>request</a>s), the user agent MUST NOT
        provide the user with that same indication.

        The user agent SHOULD instead give an indication that <a>mixed
        content</a> is present.

    If a mixed content indication is present, it MUST be made available
    through accessibility APIs for users of assistive technologies.

    Note: This requirement holds even in the context of an   
    <a href="https://cabforum.org/about-ev-ssl/">EV status</a> [[CAB]]. An EV
    certificate's indicator does not override the necessity to notify
    users of mixed content violations.
  </section>

  <section>
    <h3 id="requirements-user-controls">User Controls</h3>

    A user agent MAY offer users the ability to directly decide whether or not
    to treat <strong>all</strong> <a>mixed content</a> as <a>blockable</a>
    (meaning that even <a>optionally-blockable</a> mixed content would be
    blocked).

    Note: It is <em>strongly recommended</em> that users take advantage of such
    an option if provided.

    A user agent MAY offer users the ability to override its decision to block
    <a>blockable</a> mixed content on a particular page.

    Note: Practically, a user agent probably can't get away with not offering
    such a back door. That said, allowing mixed script is in particular a very
    dangerous option, and each user agent
    <a href="http://tools.ietf.org/html/rfc6919#section-3">REALLY SHOULD NOT</a>
    [[RFC6919]] present such a choice to users without careful consideration and
    communication of the risk involved.

    Any such controls offered by a user agent MUST also be offered through
    accessibility APIs for users of assistive technologies.
  </section>

  <section>
    <h3 id="service-workers">Service Workers</h3>

    The fact that Service Workers sit inbetween a document and the network means
    that we need to special-case requests made in those contexts. In particular,
    they should be able to cache the results of insecure requests, provided that
    those requests were triggered from a document (which, presumably, ensures
    that they'll be used in an <a>optionally-blockable</a> context). Those
    insecure results, however, cannot be exposed to the Service Worker, nor
    should the Service Worker be allowed to launder responses to
    <a>optionally-blockable</a> requests into responses to <a>blockable</a>
    requests.

    To that end:

    1.  [[#should-block-fetch]] has some carve-outs for the <code>fetch</code>
        request context, with the intent of allowing a Service Worker to copy
        a request as part of its response to a Fetch event (e.g.
        <code>fetch(event.response)</code> should be executable inside the
        event handler.

        The <code>fetch</code> request context will continue to be treated as
        <a>blockable</a> when executed outside the context of a Fetch event,
        which of course includes document contexts.

    2.  [[#should-block-response]] verifies that the incoming response has the
        same security characteristics that were allowed for the request. That
        is, a Service Worker will not be able to replace a request for a secure
        script with a cached response for an insecure resource.
  </section>

  <section>
    <h3 id="further-action">Further Action</h3>

    A user agent is encouraged to take further action above and beyond the
    requirements this document outlines in order to discourage developers from
    embedding mixed content.

    For instance, a user agent could:
    
    <ol>
      <li>
        Interpret the presence of a <code>Strict-Transport-Security</code>
        header field as forcing all content into the <a>blockable</a> category
        [[RFC6797]], or as a signal to enable <a>strict mode</a> for mixed
        content checking.
      </li>
      <li>
        Modify requests for <a>optionally-blockable</a> resources which are
        <a>mixed content</a> in order to reduce the risk to users: cookies
        and other authentication tokens could be stripped from the requests,
        automatic scheme upgrades could be attempted, and so on.
      </li>
      <li>
        Treat <a>optionally-blockable</a> resources inside <a>nested browsing
        contexts</a> as <a>blockable</a>, to allow sites to embed resources
        without fear of introducing mixed content.
      </li>
    </ol>
  </section>
</section>

<!--
   ███     ██████  ██    ██ ██    ██  ███████  ██      ██ ██       ████████ ████████   ██████   ████████ ██     ██ ████████ ██    ██ ████████  ██████
  ██ ██   ██    ██ ██   ██  ███   ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ███   ███ ██       ███   ██    ██    ██    ██
 ██   ██  ██       ██  ██   ████  ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██        ██       ████ ████ ██       ████  ██    ██    ██
██     ██ ██       █████    ██ ██ ██ ██     ██ ██  ██  ██ ██       ██████   ██     ██ ██   ████ ██████   ██ ███ ██ ██████   ██ ██ ██    ██     ██████
█████████ ██       ██  ██   ██  ████ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ██     ██ ██       ██  ████    ██          ██
██     ██ ██    ██ ██   ██  ██   ███ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ██     ██ ██       ██   ███    ██    ██    ██
██     ██  ██████  ██    ██ ██    ██  ███████   ███  ███  ████████ ████████ ████████   ██████   ████████ ██     ██ ████████ ██    ██    ██     ██████
-->
<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  In addition to the wonderful feedback gathered from the WebAppSec WG, the
  Chrome security team was invaluable in preparing this specification. In
  particular, Chris Palmer, Chris Evans, Ryan Sleevi, Michal Zalewski, Ken
  Buchanan, and Tom Sepez gave lots of early feedback. Anne van Kesteren
  explained Fetch and helped define the interface to this specification.
  Brian Smith helped keep the spec focused, trim, and sane.
</section>
