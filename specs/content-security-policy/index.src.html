<h1>Content Security Policy Level 3</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/CSP3/
TR: http://www.w3.org/TR/CSP3/
Shortname: CSP
Level: 3
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This document defines a mechanism by which web developers can control the
  resources which a particular page can fetch or execute, as well as a number
  of security-relevant policy decisions.
Indent: 2
!Bug Reports: <a href="https://github.com/w3c/webappsec/issues/new?title=CSP3:%20">via the w3c/webappsec repository on GitHub</a>
Markup Shorthands: css off
</pre>
<pre class="anchors">
spec: ES2015; urlPrefix: http://www.ecma-international.org/ecma-262/6.0/index.html
  type: method
    text: eval(); url: sec-eval-x
spec: DOM; urlPrefix: http://www.w3.org/TR/dom/
  type: interface
    text: Node; url: interface-node
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: main fetch
    text: parse a header value; url: concept-header-parse
    text: request; url: concept-request
    text: response; url: concept-response
  type: attribute
    text: client; for: Request; url: concept-request-client
    text: url; for: Request; url: concept-request-url
    text: url; for: Response; url: concept-response-url
    text: header list; for: Response; url: concept-response-header-list
  type: interface
    text: Request
spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: dfn
    urlPrefix: embedded-content-0.html
      text: an iframe srcdoc document
    urlPrefix: browsers.html
      text: active document
      text: browsing context
      text: create a document object
      text: creator document
      text: nested browsing context
      text: nested through; url: browsing-context-nested-through
    urlPrefix: webappapis.html
      text: environment settings object; url: settings-object
      text: global object
      text: incumbent settings object
      text: relevant settings object; url: relevant-settings-object-for-a-global-object
      text: responsible browsing context
    urlPrefix: infrastructure.html
      text: ASCII case-insensitive match; url: ascii-case-insensitive
      text: reflect
    urlPrefix: document-metadata.html
      text: pragma directives
  type: element
    urlPrefix: document-metadata.html
      text: base; url: the-base-element
      text: head; url: the-head-element
      text: link; url: the-link-element
      text: meta; url: the-meta-element
      text: style; url: the-style-element
    urlPrefix: embedded-content-0.html
      text: iframe; url: the-iframe-element
    urlPrefix: scripting-1.html
      text: script; url: the-script-element
  type: element-attr
    urlPrefix: document-metadata.html
      text: content; for: meta; url: attr-meta-content
      text: http-equiv; for: meta; url: attr-meta-http-equiv
    urlPrefix: embedded-content-0.html
      text: srcdoc; for: iframe; url: attr-iframe-srcdoc
  type: interface
    urlPrefix: dom.html
      text: Document
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: local scheme
  type: attribute
    text: scheme; for: URL; url: concept-url-scheme
  type: interface;
    text: URL
spec: WORKERS; urlPrefix: http://www.w3.org/TR/workers/
  type: interface
    text: Worker
spec: RFC3986; urlPrefix: https://tools.ietf.org/html/rfc3986
  type: grammar
    text: path; url: section-3.3
    text: scheme; url: section-3.1
spec: RFC5234; urlPrefix: https://tools.ietf.org/html/rfc5234
  type: grammar
    text: ALPHA; url: appendix-B.1
    text: DIGIT; url: appendix-B.1
    text: VCHAR; url: appendix-B.1
    text: WSP; url: appendix-B.1
spec: RFC5890; urlPrefix: https://tools.ietf.org/html/rfc5890
  type: dfn
    text: label; url: section-2.2
spec: RFC6454; urlPrefix: https://tools.ietf.org/html/rfc6454
  type: dfn
    text: globally unique identifier; url: section-2.3
    text: origin; url: section-3.2
    text: the same; url: section-5
spec: RFC7230; urlPrefix: https://tools.ietf.org/html/rfc7230
  type: grammar
    text: BWS; url: section-3.2.3
    text: OWS; url: section-3.2.3
    text: RWS; url: section-3.2.3
    text: quoted-string; url: section-3.2.6
    text: token; url: section-3.2.6
spec: RFC7231; urlPrefix: https://tools.ietf.org/html/rfc7231
  type: dfn
    url: section-3
      text: resource representation
      text: representation

spec: HTML; text: run a worker; url: https://html.spec.whatwg.org/multipage/workers.html#run-a-worker; type: dfn
</pre>
<pre class="biblio">
{
  "ES2015": {
    "authors": [ "Allen Wirfs-Brock" ],
    "href": "http://www.ecma-international.org/ecma-262/6.0/index.html",
    "title": "ECMAScript® 2015 Language Specification",
    "publisher": "ECMA"
  }
}
</pre>
<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  [INTRODUCTION GOES HERE]

  <h3 id="examples">Examples</h3>

  <h4 id="example-basic">Control Execution</h4>

  <div class="example">
    The developers at <code>https://example.com</code> want to protect
    themselves against cross-site scripting attacks. They can mitigate the
    risk of script injection by ensuring that their trusted CDN is the only
    origin from which script can load and execute. Moreover, they wish to
    ensure that no plugins can execute in their pages' contexts. The
    following policy has that effect:

    <pre>
      Content-Security-Policy: script-src https://cdn.example.com/scripts/; object-src 'none'
    </pre>
  </div>

  <h3 id="goals">Goals</h3>

  Content Security Policy aims to do to a few related things:

  1.  Mitigate the risk of content-injection attacks by giving developers
      fairly granular control over

      *   The resources which can be requested (and subsequently embedded or
          executed) on behalf of a specific {{Document}} or {{Worker}}

      *   The execution of inline script

      *   Dynamic code execution (via {{eval()}} and similar constructs)

      *   The application of inline style

  2.  Mitigate the risk of attacks which require a resource to be embedded
      in a malicious context ("Pixel Perfect", etc) by giving developers
      granular control over the origins which can embed a given resource.

  3.  Provide a policy framework which allows developers to tweak
      security-relevant settings.

  4.  Provide a reporting mechanism which allows developers to detect flaws
      being exploited in the wild.

  <h3 id="changes-from-level-2">Changes from Level 2</h3>

  This document describes an evolution of the
  <a href="http://www.w3.org/TR/CSP2/">Content Security Policy Level 2
  specification</a>. The following is a high-level overview of the changes:

  1.  The specification has been rewritten from the ground up in terms of the
      [[FETCH]] specification, which should make it simpler to integrate CSP's
      requirements and restrictions with other specifications (and with
      Service Workers in particular).

  2.  The <code>frame-src</code> directive, which was deprecated in CSP Level
      2, has been removed.
</section>

<!-- Big Text: Framework -->
<section>
  <h2 id="framework">Framework</h2>

  A <dfn local-lt="policies">policy</dfn> defines a set of allowed and
  restricted behaviors, and has the following attributes:

  :   <dfn for="policy">directive list</dfn>
  ::  A set of <a>directives</a> that define the behaviors the policy
      allows and restricts. Unless otherwise stated, its value is the empty set.
  :   <dfn for="policy">type</dfn>
  ::  Either "<code>enforce</code>", meaning that policy violation are actively
      prevented, or "<code>report-only</code>", meaning that policy violations
      are passively reported and allowed to proceed. Unless otherwise stated,
      its value is "<code>enforce</code>".

  A <dfn>directive</dfn> defines a specific behavior, and has the following
  properties:

  :   <dfn for="directive">name</dfn>
  ::  One of "<code>base-uri</code>", "<code>child-src</code>",
      "<code>connect-src</code>", "<code>default-src</code>",
      "<code>font-src</code>", "<code>form-action</code>",
      "<code>frame-ancestors</code>", "<code>img-src</code>",
      "<code>media-src</code>", "<code>object-src</code>",
      "<code>plugin-types</code>", "<code>report-uri</code>",
      "<code>reports</code>", "<code>sandbox</code>",
      "<code>script-src</code>", "<code>style-src</code>".
      The behaviors associated with each possible value are described in
      [[#csp-directives]].
  :   <dfn for="directive">value</dfn>
  ::  A string. Unless otherwise stated, its value is the empty string. Parsing
      rules for <a>directive</a>'s values are described in [[#csp-directives]].

  A <dfn>source list directive</dfn> is a specific type of <a>directive</a>
  whose value is a space-separated list of source expressions.

  The <dfn local-lt="effective directive name">effective directive name for a
  <code>Request</code></dfn> is the name of the <a>directive</a> which will
  determine whether the request will be allowed or blocked.

  The <dfn local-lt="controlling directive">controlling directive for a
  <code>Request</code></dfn> is the <a>directive</a> which, given the
  {{Request}}'s properties, determines whether it will be allowed or
  blocked. This will either be a <a>directive</a> whose name is the <a>effective
  directive name</a>, a <a>directive</a> whose name is <code>default-src</code>,
  or <code>null</code>. A detailed definition can be found in
  [[#get-controlling-directive]].

</section>

<!-- Big Text: Delivery -->
<section>
  <h2 id="policy-delivery">
    Policy Delivery
  </h2>

  This document defines four delivery mechanisms for a resource's policy:

  1.  An HTTP response header (defined in [[#csp-header]] and [[#cspro-header]])
      which declares a policy as a string and applies it to the resource which
      which the header is delivered. The policy syntax is defined in
      [[#syntax]].

  2.  A <{meta}> element (defined in [[#meta-element]]), which declares a policy
      as a string and applies it to the resource in which the <{meta}> element
      is embedded. The policy syntax is defined in [[#syntax]].

  3.  Inheritance, which applies a policy to a <a>nested browsing context</a>
      in certain circumstances, as defined in [[#delivery-implicit]].

  4.  A JavaScript interface (defined in [[#javascript-interface]]).


  <h3 id="delivery-declarative">
    Declarative Delivery
  </h3>

  <h4 id="csp-header">
    The <code>Content-Security-Policy</code> HTTP Response Header Field
  </h4>

  The <dfn><code>Content-Security-Policy</code></dfn> HTTP response header field
  is the preferred mechanism for delivering a policy from a server to a client.
  The header's value is represented by the following ABNF [[!RFC5234]]:

  <pre>
    Content-Security-Policy = 1#<a grammar>policy-token</a>
  </pre>

  <div class="example">
    <pre>
      <a>Content-Security-Policy</a>: script-src 'self';
                               reports /csp-reporting-endpoint
    </pre>
  </div>

  A server MAY send different <code>Content-Security-Policy</code> header field
  values with different <a>representations</a> of the same resource.

  A server SHOULD NOT send more than one HTTP response header field named
  "<code>Content-Security-Policy</code>" with a given <a>resource
  representation</a>. The user agent MUST <a>enforce</a> each of the policies
  contained in each such header field as described in
  [[#algorithms-application]].

  <h4 id="cspro-header">
    The <code>Content-Security-Policy-Report-Only</code> HTTP Response Header Field
  </h4>

  The <dfn><code>Content-Security-Policy-Report-Only</code></dfn> HTTP response
  header field allows web developers to experiment with policies by monitoring
  (but not enforcing) their effects. The header's value is represented by the
  following ABNF [[!RFC5234]]:

  <pre>
    Content-Security-Policy-Report-Only = 1#<a grammar>policy-token</a>
  </pre>

  This header field allows developers to piece together their security policy in
  an iterative fashion, deploying a report-only policy based on their best
  estimate of how their site behaves, watching for violation reports, and then
  moving to an enforced policy once they've gained confidence in that behavior.

  <div class="example">
    <pre>
      <a>Content-Security-Policy-Report-Only</a>: script-src 'self';
                                           reports /csp-reporting-endpoint
    </pre>
  </div>

  A server MAY send different <code>Content-Security-Policy-Report-Only</code>
  header field values with different <a>representations</a> of the same
  resource.

  A server SHOULD NOT send more than one HTTP response header field named
  "<code>Content-Security-Policy-Report-Only</code>" with a given <a>resource
  representation</a>. The user agent MUST <a>monitor</a> each of the policies
  contained in each such header field as described in
  [[#algorithms-application]].

  Note: The <code><a>Content-Security-Policy-Report-Only</a></code> header is
  <strong>not</strong> supported inside a <{meta}> element.

  <h4 id="meta-element">
    The <code>&lt;meta&gt;</code> element
  </h4>

  A {{Document}} may deliver a policy via one or more HTML <{meta}> elements
  whose <{meta/http-equiv}> attributes are an <a>ASCII case-insensitive
  match</a> for the string "<code>Content-Security-Policy</code>". For example:

  <div class="example">
    <pre>
      &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'"&gt;
    </pre>
  </div>

  Implementation details can be found in [[#apply-via-meta]].

  Authors are <em>strongly encouraged</em> to place <{meta}> elements as early
  in the document as possible, because policies in <{meta}> elements are not
  applied to content which precedes them. In particular, note that resources
  fetched or prefetched using the <code>Link</code> HTTP response header
  field, and resources fetched or prefetched using <{link}> and <{script}>
  elements which precede a <{meta}>-delivered policy will not be blocked.

  Note: A policy specified via a <{meta}> element will be enforced along with
  any other policies active for the protected resource, regardless
  of where they're specified. The general impact of enforcing multiple
  policies is described in [[#multiple-policies]].

  Note: Modifications to the <{meta/content}> attribute of a <{meta}> element
  after the element has been parsed will be ignored.

  Note: The <code><a>Content-Security-Policy-Report-Only</a></code>
  header is <em>not</em> supported inside a <{meta}> element.

  <h3 id="delivery-implicit">
    Implicit Delivery 
  </h3>

  Resources with <a>local schemes</a> (e.g. <code>about</code>,
  <code>blob:</code>, <code>data:</code>, and <code>filesystem:</code>), as well
  as resouces embedded via <{iframe}>'s <{iframe/srcdoc}> attribute, are
  considered same-origin with the origin that created them, but have no
  mechanism for header-based policy delivery. To ensure that this property
  doesn't allow a trivial bypass of a page's policy (by creating a
  <code>blob:</code> and embedding it in an <{iframe}>, for instance), these
  kinds of resources inherit the policy of their embedding context, as described
  in [[#apply-to-document]], [[#apply-to-worker]], and
  [[#apply-to-srcdoc-document]].

  ISSUE(w3c/webappsec#451): We should consider extending this to include
  auxiliary browsing contexts, not just nested browsing contexts.

  <h3 id="javascript-interface">
    Imperative Delivery
  </h3>

  Developers may manipulate a page's policy via a JavaScript API which allows
  construction of {{SecurityPolicy}} objects, and the application of those
  objects to an <a>environment settings object</a>.

  <h4 id="javascript-application">
    Applying a Policy
  </h4>

  A {{SecurityPolicy}} can be applied to an <a>environment settings object</a>
  via the following interfaces:

  <pre class="idl">
    partial interface Window {
      void applySecurityPolicy(SecurityPolicy policy);
    };
  </pre>
  <dl dfn-for="Window">
    <dt><dfn method>applySecurityPolicy(policy)</dfn></dt>
    <dd>
      To execute this method, execute [[#apply-to-global-object]] on
      <var>policy</var>'s associated <a>policy</a> and the {{Window}} object.
    </dd>
  </dl>

  <pre class="idl">
    partial interface WorkerGlobalScope {
      void applySecurityPolicy(SecurityPolicy policy);
    };
  </pre>
  <dl dfn-for="WorkerGlobalScope">
    <dt><dfn method>applySecurityPolicy(policy)</dfn></dt>
    <dd>
      To execute this method, execute [[#apply-to-global-object]] on
      <var>policy</var>'s associated <a>policy</a> and the {{WorkerGlobalScope}}
      object.
    </dd>
  </dl>

  <div class="example">
    To apply the policy <code>script-src 'self'; object-src 'none'</code> from
    JavaScript inside a {{Worker}} or {{Document}}, execute the following code:

    <pre>
      var policy = new SecurityPolicy("script-src 'self'; object-src 'none'");
      self.applySecurityPolicy(policy);
    </pre>
  </div>

  ISSUE: Maybe this makes more sense as `window.csp.apply()`? Which would also
  allow `window.csp.enforced` and `window.csp.monitored` as sequences of
  {{SecurityPolicy}} objects?

  <h4 id="idl-securitypolicy">
    <code>SecurityPolicy</code> Interface
  </h4>

  A policy object is defined via the following IDL:

  <pre class="idl">
    enum SecurityPolicyType {
      "enforce",
      "report-only"
    };

    [Constructor(DOMString policy, SecurityPolicyType type), Exposed=(Window,Worker)]
    interface SecurityPolicy {
      boolean requestMatches(Request request);
      boolean nodeMatches(Node node);
  
      readonly attribute FrozenArray&lt;SecurityPolicyDirective&gt; directives;
      readonly attribute SecurityPolicyType type;
      readonly attribute USVString reportingEndpoint;
    };
  </pre>

  A {{SecurityPolicy}} object has an internal slot named
  <dfn attribute for="SecurityPolicy">\[[policy]]</dfn>, which contains a
  <a>policy</a>. Unless otherwise stated, its value is <code>null</code>.

  The <dfn for="SecurityPolicy" attribute>directives</dfn> attribute's getter
  returns a list of {{SecurityPolicyDirective}}s corresponding to
  {{SecurityPolicy/[[policy]]}}'s <a for="policy">directive list</a>

  The <dfn for="SecurityPolicy" attribute>type</dfn> attribute's getter
  returns the value of {{SecurityPolicy/[[policy]]}}'s <a for="policy">type</a>.

  The <dfn for="SecurityPolicy" attribute>reportingEndpoint</dfn> attribute's
  getter returns the serialization of the <a for="directive">value</a> of
  the <a>directive</a> in {{SecurityPolicy/[[policy]]}}'s
  <a for="policy">directive list</a> with a <a for="directive">name</a> of
  "<code>report-uri</code>", if present. If no such directive is present, the
  empty string is returned.

  The <dfn constructor for="SecurityPolicy">SecurityPolicy(policy, type)</dfn>
  constructor, when invoked, MUST execute the following steps:

  1.  Let <var>policy list</var> be the result of executing
      [[#parse-policy-string]] on <var>policy</var>.

  2.  If <var>policy list</var> does not have exactly one element, throw a
      <code>SyntaxError</code> exception, and abort the remaining steps.

  3.  Set <code>this@</code>{{SecurityPolicy/[[policy]]}} to the only element
      in <var>policy list</var>.

  4.  Return <code>this</code>.

  The <dfn method for="SecurityPolicy">requestMatches(request)</dfn> method
  returns <code>true</code> if [[#match-request-to-directive-list]] returns
  <code>Matches</code> when executed upon <var>request</var> and
  {{SecurityPolicy/[[policy]]}}'s <a for="policy">directive list</a>, and
  <code>false</code> otherwise.

  The <dfn method for="SecurityPolicy">nodeMatches(node)</dfn> method returns
  <code>true</code> if [[#match-node-to-directive-list]] returns
  <code>Matches</code> when executed upon <var>node</var> and
  {{SecurityPolicy/[[policy]]}}'s <a for="policy">directive list</a>, and
  <code>false</code> otherwise.

  <h4 id="idl-securitypolicydirective">
    <code>SecurityPolicyDirective</code> Interface
  </h4>

  Policy objects contain a list of directives, each defined according to the
  following IDL:

  <pre class="idl">
    enum DirectiveName {
      "base-uri",
      "child-src",
      "connect-src",
      "default-src",
      "font-src",
      "form-action",
      "frame-ancestors",
      "img-src",
      "media-src",
      "object-src",
      "plugin-types",
      "report-uri",
      "reports",
      "sandbox",
      "script-src",
      "style-src"
    };

    [Constructor(DOMString name, DOMString value), Exposed=(Window,Worker)]
    interface SecurityPolicyDirective {
      boolean requestMatches(Request request);
      boolean nodeMatches(Node node);

      readonly attribute DirectiveName name;  
    };
  </pre>
  
  A {{SecurityPolicyDirective}} object has an internal slot named
  <dfn attribute for="SecurityPolicyDirective">\[[directive]]</dfn>, which
  contains a <a>directive</a>. Unless otherwise specified, its value is
  <code>null</code>.

  The <dfn attribute for="SecurityPolicyDirective">name</dfn> attribute's
  getter returns {{SecurityPolicyDirective/[[directive]]}}'s
  <a for="directive">name</a>.

  The <dfn attribute for="SecurityPolicyDirective">value</dfn> attribute's
  getter returns {{SecurityPolicyDirective/[[directive]]}}'s
  <a for="directive">value</a>.

  The <dfn constructor for="SecurityPolicyDirective">SecurityPolicyDirective(name, value)</dfn>
  constructor, when invoked, MUST execute the following steps:

  1.  If <var>name</var> is not a valid {{DirectiveName}}, throw a
      <code>SyntaxError</code> exception, and abort the remaining steps.

  2.  Let <var>directive</var> be a new <a>directive</a> with a
      <a for="directive">name</a> of <var>name</var> and a
      <a for="directive">value</a> of <var>value</var>.

  3.  Set <code>this@</code>{{SecurityPolicyDirective/[[directive]]}} to
      <var>directive</var>.

  4.  Return <code>this</code>.

  The <dfn method for="SecurityPolicyDirective">requestMatches(request)</dfn>
  method returns <code>true</code>.

  The <dfn method for="SecurityPolicyDirective">nodeMatches(node)</dfn> method
  returns <code>true</code>.

  Note: Directives which operate on either {{Request}}s or {{Node}}s are
  expected to inherit from {{SecurityPolicyDirective}} and override these
  method implementations. {{SourceListDirective}} is one example of this.

  <h4 id="idl-sourcelistdirective">
    <code>SourceListDirective</code> Interface
  </h4>

  Directives whose values are <a>source lists</a> are parsed into
  {{SourceListDirective}} objects (which subclass {{SecurityPolicyDirective}}).
  These are defined according to the following IDL:

  <pre class="idl">
    [Constructor(DOMString name, DOMString value), Exposed=(Window,Worker)]
    interface SourceListDirective : SecurityPolicyDirective {
      readonly attribute FrozenArray&lt;SourceExpression&gt; sources;
    };
  </pre>

  The <dfn constructor for="SourceListDirective">SourceListDirective(name, value)</dfn>
  constructor, when invoked, MUST execute the following steps:

  1.  If <var>name</var> is not a valid {{DirectiveName}}, throw a
      <code>SyntaxError</code> exception, and abort the remaining steps.

  2.  Let <var>directive</var> be a new <a>directive</a> with a
      <a for="directive">name</a> of <var>name</var> and a
      <a for="directive">value</a> of <var>value</var>.

  3.  Set <code>this@</code>{{SecurityPolicyDirective/[[directive]]}} to
      <var>directive</var>.

  4.  <code>this@</code>Set {{SourceListDirective/sources}} to the result of
      executing [[#parse-source-list]] on <var>value</var>.

  5.  Return <code>this</code>.

  The <dfn method for="SourceListDirective">requestMatches(request)</dfn>
  method, when invoked, MUST execute the following steps:

  1.  Let <var>url</var> be <var>request</var>'s {{Request/url}}.

  2.  For each <var>expression</var> in this object's
      {{SourceListDirective/sources}} attribute:

      1.  If <var>expression</var>'s {{SourceExpression/urlMatches(url)}}
          returns <code>true</code> when executed upon <var>url</var>, return
          <code>true</code>.

  3.  Return <code>false</code>.

  The <dfn method for="SourceListDirective">nodeMatches(node)</dfn> method,
  when invoked, MUST execute the following steps:

  1.  For each <var>expression</var> in this object's
      {{SourceListDirective/sources}} attribute:

      1.  If <var>expression</var>'s {{SourceExpression/nodeMatches(node)}}
          returns <code>true</code> when executed upon <var>node</var>,
          return <code>true</code>.

  2.  Return <code>false</code>.

  <h4 id="idl-sourceexpression">
    <code>SourceExpression</code> Interface
  </h4>

  {{SourceListDirective}} objects' {{SourceListDirective/sources}} attribute
  contains the list of <a>source expressions</a> that make up the directive's
  value. These are represented as {{SourceExpression}} objects according to
  the following IDL:

  <pre class="idl">
    [Constructor(DOMString value), Exposed=(Window,Worker)]
    interface SourceExpression {
      boolean urlMatches(USVString url);
      boolean nodeMatches(Node node);

      readonly attribute DOMString value;
    };
  </pre>
  <dl dfn-for="SourceExpression">
    <dt><dfn attribute>value</dfn></dt>
    <dd>
      The expression's value. <code>script-src https://example.com/
      'nonce-abcde'</code> will, for example, produce two {{SourceExpression}}
      objects, one with a value of "https://example.com/", the other with a
      value of "'nonce-abcde'".
    </dd>
    <dt><dfn method>urlMatches(url)</dfn></dt>
    <dd>
      This method returns <code>true</code> if executing
      [[#match-url-to-source-expression]] on <var>url</var> and the object's
      {{SourceExpression/value}} attribute returns <code>Matches</code>, and
      <code>false</code> otherwise.

      <pre class="argumentdef" for="SourceExpression/urlMatches(url)">
        url: The URL to match against the SourceExpression.
      </pre>
    </dd>
    <dt><dfn method>nodeMatches(node)</dfn></dt>
    <dd>
      This method returns <code>true</code> if executing
      [[#match-node-to-source-expression]] on <var>node</var> and the object's
      {{SourceExpression/value}} attribute returns <code>Matches</code>, and
      <code>false</code> otherwise.

      <pre class="argumentdef" for="SourceExpression/nodeMatches(node)">
        node: The Node which will be matched against the directive.
      </pre>
    </dd>
  </dl>
</section>

<!-- Big text: Application -->
<section>
</section>

<!-- Big Text: Syntax -->
<section>
  <h2 id="syntax">
    Policy Syntax
  </h2>

  A <dfn local-lt="policy string">serialized Content Security Policy</dfn>
  consists of a semicolon-delimited list of directives. Each directive consists
  of a key and (optionally) a value, defined by the following ABNF [[!RFC5234]]:

  <pre dfn-type="grammar" link-type="grammar">
    <dfn>policy-token</dfn> = <a>directive-token</a> *( <a>OWS</a> ";" [ <a>OWS</a> <a>directive-token</a> ] )
    <dfn>directive-token</dfn> = <a>directive-name</a> [ <a>RWS</a> <a>directive-value</a> ]
    <dfn>directive-name</dfn> = 1*( <a>ALPHA</a> / <a>DIGIT</a> / "-" )
    <dfn>directive-value</dfn> = *( <a>WSP</a> / &lt;<a>VCHAR</a> except ";" and ","&gt; )
  </pre>

  <div link-type="grammar" class="note">
    Note: The <a>BWS</a>, <a>OWS</a>, and <a>RWS</a> rules are defined in
    [[RFC7230]]. <a>ALPHA</a>, <a>DIGIT</a>, <a>VCHAR</a>, and <a>WSP</a>
    are defined in [[RFC5234]].
  </div>

  <h3 id="syntax-source-list">
    Source List Syntax
  </h3>

  The syntax for individual directives is defined in [[#csp-directives]], though
  many directives share a common <dfn>source list</dfn> syntax defined below.

  A source list represents a set of locations from which content of a specified
  type can be fetched and potentially embedded or executed. Locations are
  represented by one of the following types of <dfn>source expression</dfn>:

  1.  Keywords such as <a grammar><code>'none'</code></a> and
      <a grammar><code>'self'</code></a> (which match nothing and the current
      URL's origin, respectively)

  2.  Serialized URLs such as <code>https://example.com/path/to/file.js</code>
      (which matches a specific file) or <code>https://example.com/</code>
      (which matches everything on that origin)

  3.  Schemes such as <code>https:</code> (which matches any resource having
      the specified scheme)

  4.  Hosts such as <code>example.com</code> (which matches any resource on
      the host, regardless of scheme) or <code>*.example.com</code> (which
      matches any resource on the host or any of its subdomains (and any of
      its subdomains' subdomains, and so on))

  5.  Nonces such as <code>'nonce-qwertyu12345'</code> (which can match specific
      elements on a page)

  6.  Digests such as <code>'sha256-abcd...'</code> (which can match specific
      elements on a page)

  These representations are defined by the following ABNF [[!RFC5234]]:

  <pre dfn-type="grammar" link-type="grammar">
    <dfn>source-list</dfn>       = <a>source-expression</a> *( <a>RWS</a> <a>source-expression</a> )
                        / "<dfn>'none'</dfn>"
    <dfn>source-expression</dfn> = <a>scheme-source</a> / <a>host-source</a> / <a>keyword-source</a>
                        / <a>nonce-source</a> / <a>hash-source</a>

    ; Schemes: `scheme:`
    <dfn>scheme-source</dfn> = <a>scheme</a> ":"

    ; Hosts: `example.com` / `*.example.com` / `https://*.example.com:12/path/to/file.js`
    <dfn>host-source</dfn> = [ <a>scheme-part</a> "://" ] <a>host-part</a> [ <a>port-part</a> ] [ <a>path-part</a> ]
    <dfn>scheme-part</dfn> = <a>scheme</a>
    <dfn>host-part</dfn>   = "*" / [ "*." ] 1*<a>host-char</a> *( "." 1*<a>host-char</a> )
    <dfn>host-char</dfn>   = <a>ALPHA</a> / <a>DIGIT</a> / "-"
    <dfn>port-part</dfn>   = ":" ( 1*<a>DIGIT</a> / "*" )
    <dfn>path-part</dfn>   = <a>path</a>
   
    ; Keywords:
    <dfn>keyword-source</dfn> = "<dfn>'self'</dfn>" / "<dfn>'unsafe-inline'</dfn>" / "<dfn>'unsafe-eval'</dfn>" 

    ; Nonces: 'nonce-[nonce goes here]'
    <dfn>nonce-source</dfn>  = "'nonce-" <a>base64-value</a> "'"
    <dfn>base64-value</dfn>  = 1*( <a>ALPHA</a> / <a>DIGIT</a> / "+" / "/" )*2( "=" ) 

    ; Digests: 'sha256-[digest goes here]'
    <dfn>hash-source</dfn>    = "'" <a>hash-algorithm</a> "-" <a>base64-value</a> "'"
    <dfn>hash-algorithm</dfn> = "sha256" / "sha384" / "sha512"
  </pre>

  Note: The <a grammar>scheme</a> and <a grammar>path</a> rules are defined in
  [[RFC3986]].

  The <a grammar>host-char</a> production intentionally contains only ASCII
  characters; internationalized domain names cannot be entered directly into a
  <a>policy string</a>, but instead MUST be Punycode-encoded [[!RFC3492]]. For
  example, the domain <code>üüüüüü.de</code> MUST be represented as
  <code>xn--tdaaaaaa.de</code>.

  Note: Though IP address do match the grammar above, only
  <code>127.0.0.1</code> will actually match a URL when used in a source
  expression (see [[#match-url-to-source-list]] for details). The security
  properties of IP addresses are suspect, and authors ought to prefer hostnames
  whenever possible.

  <h4 id="script-src-the-nonce-attribute">
    The <code>nonce</code> attribute
  </h4>

  Nonce sources require a new <code>nonce</code> attribute to be added to
  both <{script}> and <{style}> elements.

  <pre class="idl">
    partial interface HTMLScriptElement {
      attribute DOMString nonce;
    };
  </pre>
  <dl dfn-for="HTMLScriptElement">
    <dt><dfn attribute>nonce</dfn></dt>
    <dd>
      This attribute <a>reflects</a> the value of the element's
      <code><dfn element-attr for="script">nonce</a></code>
      content attribute.
    </dd>
  </dl>
  <pre class="idl">
    partial interface HTMLStyleElement {
      attribute DOMString nonce;
    };
  </pre>
  <dl dfn-for="HTMLStyleElement">
    <dt><dfn attribute>nonce</dfn></dt>
    <dd>
      This attribute <a>reflects</a> the value of the element's
      <code><dfn element-attr for="style">nonce</a></code>
      content attribute.
    </dd>
  </dl>
</section>

<!-- Big Text: Reporting -->
<section>
  <h2 id="reporting">
    Reporting
  </h2>
</section>

<!-- Big Text: Directives -->
<section>
  <h2 id="csp-directives">
    Content Security Policy Directives
  </h2>
  
  This specification defines a number of types of <a>directives</a> which allow
  developers to control certain aspects of their sites' behavior. The defined
  directives fall into one of several categories:

  1.  <dfn>Request Directives</dfn> control the locations from which certain
      resource types may be loaded. For instance, <a>script-src</a> allows
      developers to whitelist trusted sources of script to execute on a page,
      while <a>font-src</a> controls the sources of web fonts.

  2.  ...

  To mitigate the risk of cross-site scripting attacks, web developers SHOULD
  include directives that regulate sources of script and plugins. They can do
  so by including:

  *   Both the <a>script-src</a> and <a>object-src</a> directives, or
  *   a <a>default-src</a> directive

  In either case, developers SHOULD NOT include either
  <a grammar><code>'unsafe-inline'</code></a>, or <code>data:</code> as valid
  sources in their policies. Both enable XSS attacks by allowing code to be
  included directly in the document itself; they are best avoided completely.

  <h3 id="directives-request">
    Request Directives
  </h3>

  <h4 id="directive-child-src"><code>child-src</code></h4>

  The <dfn>child-src</dfn> directive governs the creation of <a>nested browsing
  contexts</a> and Worker execution contexts. The syntax for the directive's
  name and value is described by the following ABNF:

  <pre>
    directive-name  = "child-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <div class="example">
    Given a page with the following Content Security Policy:

    <pre>
      Content-Security-Policy: child-src https://example.com/
    </pre>

    Fetches for the following code will all return network errors, as the URLs
    provided do not match <code>child-src</code>'s <a>source list</a>:

    <pre>
      &lt;iframe src="https://not-example.com"&gt;&lt;/iframe&gt;
      &lt;script&gt;
        var blockedWorker = new Worker("data:application/javascript,...");
      &lt;/script&gt;
    </pre>
  </div>

  <h4 id="directive-connect-src"><code>connect-src</code></h4>

  The <dfn>connect-src</dfn> directive restricts the URLs which can be loaded
  using script interfaces such as those defined in [[XMLHttpRequest]] and
  [[FETCH]]. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "connect-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h4 id="directive-default-src"><code>default-src</code></h4>

  The <dfn>default-src</dfn> directive serves as a fallback for the other 
  <a>request directives</a>. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "default-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h4 id="directive-font-src"><code>font-src</code></h4>

  The <dfn>font-src</dfn> directive restricts the URLs from which font resources
  may be loaded. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "font-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h4 id="directive-img-src"><code>img-src</code></h4>

  The <dfn>img-src</dfn> directive restricts the URLs from which image resources
  may be loaded. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "img-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h4 id="directive-media-src"><code>media-src</code></h4>

  The <dfn>media-src</dfn> directive restricts the URLs from which video, audio,
  and associated text track resources may be loaded. The syntax for the
  directive's name and value is described by the following ABNF:

  <pre>
    directive-name  = "media-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h4 id="directive-object-src"><code>object-src</code></h4>

  The <dfn>object-src</dfn> directive restricts the URLs from which plugins may
  be loaded. The syntax for the directive's name and value is described by the
  following ABNF:

  <pre>
    directive-name  = "object-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h4 id="directive-script-src"><code>script-src</code></h4>

  The <dfn>script-src</dfn> directive restricts the locations from which scripts
  may be executed. This includes not only URLs loaded directly into <{script}>
  elements, but also things like inline script blocks and XSLT stylesheets
  [[XSLT]] which can trigger script execution. The syntax for the directive's
  name and value is described by the following ABNF:

  <pre>
    directive-name  = "script-src"
    directive-value = <a grammar>source-list</a>
  </pre>


  <h4 id="directive-style-src"><code>style-src</code></h4>

  The <dfn>style-src</dfn> directive restricts the locations from which style
  may be applied to a {{Document}}. The syntax for the directive's name and
  value is described by the following ABNF:

  <pre>
    directive-name  = "style-src"
    directive-value = <a grammar>source-list</a>
  </pre>

  <h3 id="directives-other">
    Grabbag
  </h3>

  <h4 id="directive-base-uri"><code>base-uri</code></h4>

  The <dfn>base-uri</dfn> directive restricts the {{URL}}s which can be used in
  a {{Document}}'s <{base}> element. The syntax for the directive's name and
  value is described by the following ABNF:

  <pre>
    directive-name  = "base-uri"
    directive-value = &lt;URL&gt; ; TODO: Figure out what to use here.
  </pre>

  <h4 id="directive-form-action"><code>form-action</code></h4>
  <h4 id="directive-frame-ancestors"><code>frame-ancestors</code></h4>
  <h4 id="directive-plugin-types"><code>plugin-types</code></h4>
  <h4 id="directive-sandbox"><code>sandbox</code></h4>

  <h3 id="directives-reporting">
    Reporting Directives
  </h3>

  <h4 id="directive-report-uri"><code>report-uri</code></h4>

  The <dfn>report-uri</dfn> directive is deprecated. Please use the
  <a>reports</a> directive instead.

  <h4 id="directive-report"><code>reports</code></h4>

  The <dfn>reports</dfn> directive defines the endpoint to which violation
  reports are sent. The syntax for the directive's name and
  value is described by the following ABNF:

  <pre>
    directive-name  = "reports"
    directive-value = &lt;URL&gt; ; TODO: Figure out what to use here.
  </pre>

</section>

<!-- Big Text: Algorithms -->
<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="algorithms-fetch">Fetch Interface</h3>

  This specification provides two algorithms which allow Fetch to make decisions
  about whether or not a particular <a>request</a> should be blocked based on
  its {{Request/client}}'s Content Security Policy [[!FETCH]]. The policy check
  occurs twice: once at the top of Fetch, ensuring that outgoing requests
  satisfy the relevant policy; and once at the bottom, ensuring that incoming
  responses match as well (as they could have been modified in interesting ways
  by an intermediate Service Worker). These algorithms can be considered the
  public interface to the Content Security Policy specification:

  <h4 id="should-block-request">
    Should <var>request</var> be blocked by Content Security Policy?
  </h4>

  Given a <a>request</a> (<var>request</var>), this algorithm returns
  <code>Blocked</code> or <code>Allowed</code> based on <var>request</var>'s
  {{Request/client}}'s Content Security Policy.

  Note: [[FETCH]] calls this algorithm as step #3 of its <a>Main Fetch</a>
  algorithm.

  1.  Let <var>client</var> be <var>request</var>'s {{Request/client}}.

  2.  Return <code>Blocked</code>.

  ISSUE: We should probably expand on this definition a bit.

  <h4 id="should-block-response">
    Should <var>response</var> to <var>request</var> be blocked by Content
    Security Policy?
  </h4>

  Given a <a>response</a> (<var>response</var>) and a <a>request</a>
  (<var>request</var>), this algorithm returns <code>Blocked</code> or
  <code>Allowed</code> based on <var>request</var>'s {{Request/client}}'s
  Content Security Policy.

  Note: [[FETCH]] calls this algorithm as step #12 of its <a>Main Fetch</a>
  algorithm.

  1.  Let <var>client</var> be <var>request</var>'s {{Request/client}}.

  2.  Return <code>Blocked</code>.

  ISSUE: We should probably expand on this definition a bit.

  <h3 id="algorithms-application">
    Policy Application Algorithms
  </h3>

  ISSUE: Monkey patches gonna monkey patch. Talk to WHATWG / WICG.

  Each of the delivery mechanisms specified in [[#policy-delivery]] can be used
  to add values to one of three properties this specification adds to
  <a>environment settings objects</a> to store the relevant policy data for a
  resource:

  : <dfn export for="environment settings object">
      enforced Content Security Policies
    </dfn>
  :: A set of <a>policies</a> which are to be enforced for the settings object.
     This property's value is the empty set unless otherwise specified.
  : <dfn export for="environment settings object">
      monitored Content Security Policies
    </dfn>
  :: A list of <a>policies</a> which are to be monitored for the settings
     object. This property's value is the empty list unless otherwise specified.
  : <dfn export for="environment settings object">
      inherits Content Security Policies
    </dfn>
  :: A boolean value signifying whether or not the policies of an <a>embedding
     <code>Document</code></a> ought to be applied (as described in
     [[#get-policies]]). This property is <code>false</code> unless otherwise
     specified.

  A <a>policy</a> is <dfn export local-lt="enforcing">enforced</dfn> for an
  <a>environment settings object</a> by inserting it into the object's
  <a>enforced Content Security Policies</a> list. A string is <a>enforced</a>
  by <a>enforcing</a> each result of executing [[#parse-policy-string]] on the
  string.

  A <a>policy</a> is <dfn export local-lt="monitoring">monitored</dfn> for an
  <a>environment settings object</a> by inserting it into the object's
  <a>monitored Content Security Policies</a> list. A string is <a>monitored</a>
  by <a>monitoring</a> each result of executing [[#parse-policy-string]] on the
  string.

  <h4 id="apply-to-document">
    Apply policies to a <code>Document</code> created via a <var>response</var>
  </h3>

  When <a lt="create a Document object">creating</a> a {{Document}} object
  (<var>document</var>) for a <a>response</a> (<var>response</var>):
    
  1.  If <var>response</var>'s {{Response/url}}'s {{URL/scheme}} is a
      <a>local scheme</a>:

      1.  Set <var>document</var>'s <a>incumbent settings object</a>'s
          <code><a>inherits Content Security Policies</a></code> property to
          <code>true</code>.

  2.  Otherwise:

      1.  Execute [[#apply-policy-from-headers]] on 
          <var>response</var>'s <a attribute>header list</a> and
          <var>document</var>'s <a>incumbent settings object</a>.

  <h4 id="apply-to-srcdoc-document">
    Apply policies to an <code>IFrame</code> <code>srcdoc</code>
    <code>Document</code>
  </h4>

  When <a lt="create a Document object">creating</a> a {{Document}} object
  (<var>document</var>) for <a>an iframe srcdoc document</a>:

  1.  Set <var>document</var>'s <a>incumbent settings object</a>'s
      <code><a>inherits Content Security Policies</a></code> property to
      <code>true</code>.

  <h4 id="apply-to-worker">
    Apply policies to a <code>Worker</code>
  </h4>
  
  When <a lt="run a worker">running a worker</a> <var>worker</var> for
  <a>environment settings object</a> <var>settings</var> successfully
  executes a Fetch in its current step 4:

  1.  If <var>response</var>'s {{Response/url}}'s {{URL/scheme}} is a
      <a>local scheme</a>:

      1.  Set <var>settings</var> <code><a>inherits Content Security
          Policies</a></code> property to <code>true</code>.

  2.  Otherwise:

      1.  Execute [[#apply-policy-from-headers]] on 
          the <a>response</a>'s <a attribute>header list</a> and
          <var>settings</var>.

  Note: This is using the WHATWG's definition of "run a worker", because
  the W3C's version has no concept of environment settings objects.

  ISSUE: Does this cover Service Workers?

  <h4 id="apply-via-meta">
    Apply policies to <var>document</var> via <code>&lt;meta&gt;</code>
  </h4>

  ISSUE: Monkey-patching! Move this to HTML.

  Add the following entry to the <a>pragma directives</a> for the <{meta}>
  element:

  <dl>
    <dt>
      Content security policy
      (<code>http-equiv="content-security-policy"</code>)
    </dt>
    <dd>
      <ol>
        <li>
          If the Document's <{head}> element is not an ancestor of the <{meta}>
          element, abort these steps.
        </li>

        <li>
          If the <{meta}> element lacks a <{meta/content}> attribute, abort
          these steps.
        </li>

        <li>
          Let <var>content</var> be the value of the <{meta/content}> attribute
          of the <{meta}> element.
        </li>

        <li>
          Let <var>policy</var> be the result of executing
          [[#parse-policy-string]] on <var>content</var>.
        </li>

        <li>
          Remove all occurrences of <code>report-uri</code>,
          <code>frame-ancestors</code>, and <code>sandbox</code>
          directives from <var>policy</var>'s directive set.

          Note: User agents are encouraged to issue a warning to developers
          if one or more of these directives are included in a policy
          delivered via <{meta}>.

          ISSUE: Wire all this up once the directives exist and the policy
          object is defined.
        </li>

        <li>
          <a>Enforce</a> <var>policy</var> on the <a>incumbent settings
          object</a>.
      </ol>
    </dd>
  </dl>

  <h4 id="apply-to-global-object">
    Apply <var>policy</var> to <var>global object</var>
  </h4>

  1.  Let <var>settings</var> be the <a>relevant settings object</a> for
      <var>global object</var>.

  2.  If <var>policy</var>'s <a for="policy">type</a> attribute is
      "<code>enforce</code>", <a>enforce</a> <var>policy</var> for
      <var>settings</var>.

  3.  Otherwise, <var>policy</var>'s <a for="policy">type</a> attribute is
      "<code>report-only</code>", so <a>monitor</a> <var>policy</var> for
      <var>settings</var>.

  <h4 id="apply-policy-from-headers">
    Apply policies from <var>header list</var> to <var>environment settings
    object</var>
  </h4>

  Given a <a>response</a>'s <a attribute>header list</a> (<var>header
  list</var>) and an <a>environment settings object</a> (<var>settings</var>),
  this algorithm extracts the policies which ought to be <a>enforced</a> and
  <a>monitored</a> for the settings object, and does so:

  1.  Let <var>policy to enforce</var> be the result of
      <a lt="parse a header value">parsing</a>
      <a><code>Content-Security-Policy</code></a> in
      <var>header list</var>.

  2.  Let <var>policies</var> be the result of executing
      [[#parse-policy-string]] on <var>policy to enforce</var>.

  3.  <a>Enforce</a> each policy object in <var>policies</var> on
      <var>settings</var>.

  4.  Let <var>policy to monitor</var> be the result of
      <a lt="parse a header value">parsing</a>
      <a><code>Content-Security-Policy-Report-Only</code></a> in
      <var>header list</var>.

  5.  Let <var>policies</var> be the result of executing
      [[#parse-policy-string]] on <var>policy to monitor</var>.

  6.  <a>Monitor</a> each policy object in <var>policies</var> on
      <var>settings</var>.

  <h3 id="algorithms-parsing">Parsing Algorithms</h3>

  <h4 id="parse-policy-string">
    Parse <var>string</var> as a Content Security Policy
  </h4>

  Given a <a>policy string</a> (<var>string</var>), this algorithm will return a
  list of <a>policies</a>. In the case of a fatal parse error, this list will be
  empty.

  <h4 id="parse-source-list">
    Parse <var>string</var> as a source list
  </h4>

  Given a <a>source list directive</a>'s <a for="directive">value</a>, this
  algorithm will return a list of <a>source expressions</a>. In the case of a
  fatal parse error, this list will be empty.

  <h3 id="algorithms-matching">Matching Algorithms</h3>

  <h4 id="match-request-to-directive-list">
    Does <var>request</var> match <var>directive list</var>?
  </h4>

  ISSUE: Parse the request to determine which directive applies, find the
  relevant directive in the list, and call [[#match-url-to-source-list]].

  <h4 id="match-url-to-source-list">
    Does <var>url</var> match <var>source list</var>?
  </h4>

  Given a {{URL}} (<var>url</var>) and a <a>source list</a> (<var>list</var>),
  this algorithm returns <code>Matches</code> or <code>Does Not Match</code>.

  1.  For each <var>expression</var> in <var>list</var>:

      1.  If [[#match-url-to-source-expression]] returns <code>Matches</code>
          when executed upon <var>url</var> and <var>expression</var>, then
          return <code>Matches</code>

  2.  Return <code>Does Not Match</code>.

  <h4 id="match-url-to-source-expression">
    Does <var>url</var> match <var>source expression</var>?
  </h4>

  Given a {{URL}} (<var>url</var>) and a <a>source expression</a>
  (<var>source</var>), this algorithm returns <code>Matches</code> or <code>Does
  Not Match</code>.
 
  1.  Return <code>Does Not Match</code>.

  ISSUE: This might need a bit of polishing.

  <h4 id="match-node-to-directive-list">
    Does <var>node</var> match <var>directive list</var>?
  </h4>

  ISSUE: Parse the node to determine which directive applies, find the
  relevant directive in the list, and call [[#match-node-to-source-list]].

  <h4 id="match-node-to-source-list">
    Does <var>node</var> match <var>source list</var>?
  </h4>

  Given a {{Node}} (<var>node</var>) and a <a>source list</a> (<var>list</var>),
  this algorithm returns <code>Matches</code> or <code>Does Not Match</code>.

  1.  For each <var>expression</var> in <var>list</var>:

      1.  If [[#match-node-to-source-expression]] returns <code>Matches</code>
          when executed upon <var>node</var> and <var>expression</var>, then
          return <code>Matches</code>

  2.  Return <code>Does Not Match</code>.

  <h4 id="match-node-to-source-expression">
    Does <var>node</var> match <var>source expression</var>?
  </h4>

  Given a {{Node}} (<var>url</var>) and a <a>source expression</a>
  (<var>source</var>), this algorithm returns <code>Matches</code> or <code>Does
  Not Match</code>.
 
  1.  Return <code>Does Not Match</code>.

  ISSUE: This might need a bit of polishing.

  <h3 id="internal-helpers">Internal Helpers</h3>

  These algorithms are part of the internal processing model of Content Security
  Policy, and are not meant to be called from other specifications.

  <h4 id="get-policies">
    Gather policies for <var>environment settings object</var> and
    <var>disposition</var>
  </h4>

  Given an <a>environment settings object</a> (<var>settings</var>), and a
  <var>disposition</var> of either <code>Enforce</code> or
  <code>Monitor</code> this algorithm returns a list of <a>policies</a> which
  ought to be considered.

  In order to properly deal with inheritance, this algorithm will walk through
  a {{Document}} <var>document</var>'s <dfn>embedding documents</dfn>: the
  {{Document}} <a lt="nested through">through which</a> <var>document</var>'s
  <a>browsing context</a> is nested.

  1.  Let <var>policies</var> be an empty list.

  2.  Let <var>effective policies</var> be <var>settings</var>' <a>enforced
      Content Security Policies</a> attribute if <var>disposition</var> is
      <code>Enforce</code>, and <var>settings</var>' <a>monitored Content
      Security Policies</a> otherwise.

  3.  For each <var>policy</var> in <var>effective policies</var>:
    
      1.  Push <var>policy</var> into <var>policies</var>.

  4.  If <var>settings</var>' <a>inherits Content Security Policies</a>
      attribute is <code>true</code>:

      1.  If <var>settings</var>' <a>global object</a> is a {{Window}}:

          1.  Let <var>parent</var> be <var>settings</var>' <a>responsible
              browsing context</a>'s <a>active Document</a>'s <a>creator
              Document</a>'s <a>global object</a>'s <a>relevant settings
              object</a>.

          2.  Let <var>policies to inherit</var> be the result of executing
              [[#get-policies]] on <var>parent</var> and
              <var>disposition</var>.

          3.  For each <var>policy</var> in <var>policies to inherit</var>:
    
              1.  Push <var>policy</var> into <var>policies</var>.

      2.  Otherwise, <var>settings</var>' <a>global object</a> is a
          {{WorkerGlobalScope}}:

          1.  ISSUE: I have no idea what to do here. Anne suggests
              monkey-patching <a>run a worker</a>.

  5.  Return <var>policies</var>.

  <h4 id="get-controlling-directive">
    Get the controlling directive for <var>Request</var> from <var>policy</var>
  </h4>

  Given a {{Request}} object (<var>request</var>), and a <a>policy</a>
  (<var>policy</var>), this algorithm returns the <a>controlling directive</a>
  which controls the request. If no such directive is present in the
  given policy, this algorithm returns <code>null</code>.

  1.  Return <code>null</code>.
</section>

<!-- Big text: Security -->
<section>
  <h2 id="security-considerations">Security Considerations</h2>

  <h3 id="security-nonces">Nonce Reuse</h3>

  Nonces override the other restrictions present in the directive in which
  they're delivered. It is critical, then, that they remain unguessable, as
  bypassing a resource's policy is otherwise trivial.

  If a server delivers a <a grammar>nonce-source</a> expression as part of a
  <a>policy string</a>, the server MUST generate a unique value each time it
  transmits a policy. The generated value SHOULD be at least 128 bits long
  (before encoding), and SHOULD be generated via a cryptographically secure
  random number generator in order to ensure that the value is difficult for
  an attacker to predict.

  Note: Using a nonce to whitelist inline script or style is less secure than
  not using a nonce, as nonces override the restrictions in the directive in
  which they are present. An attacker who can gain access to the nonce can
  execute whatever script they like, whenever they like. That said, nonces
  provide a substantial improvement over <a grammar>'unsafe-inline'</a> when
  layering a content security policy on top of old code. When considering
  <a grammar>'unsafe-inline'</a>, authors are encouraged to consider nonces
  (or hashes) instead.
</section>

<!-- Big text: Authoring -->
<section>
  <h2 id="authoring-considerations">Authoring Considerations</h2>

  <h3 id="multiple-policies">
    The effect of multiple policies
  </h3>

  <em>This section is not normative.</em>

  The above sections note that when multiple policies are present, each must be
  enforced or reported, according to its type. An example will help clarify how
  that ought to work in practice. The behavior of an <code>XMLHttpRequest</code>
  might seem unclear given a site that, for whatever reason, delivered the
  following HTTP headers:

  <div class="example">
    <pre>
      Content-Security-Policy: default-src 'self' http://example.com http://example.net;
                               connect-src 'none';
      Content-Security-Policy: connect-src http://example.com/;
                               script-src http://example.com/
    </pre>
  </div>

  Is a connection to example.com allowed or not? The short answer is that the
  connection is not allowed. Enforcing both policies means that a potential
  connection would have to pass through both unscathed. Even though the second
  policy would allow this connection, the first policy contains
  <code>connect-src 'none'</code>, so its enforcement blocks the connection. The
  impact is that adding additional policies to the list of policies to enforce
  can <em>only</em> further restrict the capabilities of the protected resource.

  To demonstrate that further, consider a script tag on this page. The first
  policy would lock scripts down to <code>'self'</code>,
  <code>http://example.com</code> and <code>http://example.net</code> via the
  <code>default-src</code> directive. The second, however, would only allow
  script from <code>http://example.com/</code>. Script will only load if it
  meets both policy’s criteria: in this case, the only origin that can match
  is <code>http://example.com</code>, as both policies allow it.
</section>

<!-- Big Text: IANA -->
<section>
  <h2 id="iana-considerations">IANA Considerations</h2>

  The permanent message header field registry should be updated
  with the following registration: [[!RFC3864]]

  <h3 id="iana-csp">
    Content-Security-Policy
  </h3>

  <dl>
    <dt>Header field name</dt>
    <dd>Content-Security-Policy</dd>

    <dt>Applicable protocol</dt>
    <dd>http</dd>

    <dt>Status</dt>
    <dd>standard</dd>

    <dt>Author/Change controller</dt>
    <dd>W3C</dd>

    <dt>Specification document</dt>
    <dd>This specification (See [[#csp-header]])</dd>
  </dl>
</section>

<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  Lots of people are awesome.
</section>
