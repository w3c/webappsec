<h1>Clear Site Data</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/clear-site-data/
TR: http://www.w3.org/TR/clear-site-data/
Shortname: clear-site-data
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This document defines an imperative mechanism which allows web developers to
  instruct a user agent to clear a site's locally stored data related to a
  host and its subdomains.
Indent: 2
Level: 1
!Bug Reports: <a href="https://github.com/w3c/webappsec/issues/new?title=CLEAR:%20">via the w3c/webappsec repository on GitHub</a>
</pre>
<pre class="anchors">
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: fetching
    text: main fetch
    text: append; url: concept-header-list-append
    text: response; url: concept-response
    text: header list; for: response; url: concept-header-list
  type: interface
    text: Request; url: concept-request
  type: attribute
    text: url; for: Request; url: concept-request-url
    text: url; for: Response; url: concept-response-url
    text: client; for: Request; url: concept-request-client
    text: context; for: Request; url: concept-request-context
    text: context-frame-type; for: Request; url: concept-request-context-frame-type
    text: header-list; for: Request; url: concept-request-header-list
spec: INDEXEDDB; urlPrefix: http://www.w3.org/TR/IndexedDB/
  type: dfn
    text: database deletion steps
    text: database closing steps
    text: delete pending; url: dfn-delete-pending
  type: interface
    text: IDBDatabase; url: idl-def-IDBDatabase
spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: dfn
    urlPrefix: embedded-content-0.html
      text: an iframe srcdoc document
    urlPrefix: browsers.html
      text: ancestor browsing context
      text: active document
      text: browsing context
      text: browsing context container
      text: creating a new document object; url: create-a-document-object
      text: nested browsing context
      text: active sandboxing flag set
      text: parse a sandboxing directive; url: sandboxing:parse-a-sandboxing-directive
      text: replacement enabled
      text: exceptions enabled
      text: source browsing context
      text: reload-triggered navigation; url: reload-triggered-navigation
    urlPrefix: webappapis.html
      text: environment settings object; url: settings-object
      text: incumbent settings object
      text: responsible document
      text: responsible browsing context
      text: relevant settings object for a script
    urlPrefix: infrastructure.html
      text: split on spaces; url: split-a-string-on-spaces
  type: interface
    urlPrefix: browsers.html
      text: Location
  type: method
    urlPrefix: browsers.html
      text: reload(); for: Location; url: dom-location-reload
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/
  urlPRefix: webstorage.html
    type: dfn
      text: local storage area; url: the-localstorage-attribute
      text: session storage area; url: the-sessionstorage-attribute
    type: attribute
      text: localStorage; for: WindowLocalStorage; url: dom-localstorage
      text: sessionStorage; for: WindowSessionStorage; url: dom-sessionstorage
    type: interface
      text: Storage; url: storage-2
  urlPrefix: workers.html
    type: dfn
      text: set up a worker environment settings object
    type: interface
      text: SharedWorkers
spec: MIX; urlPrefix: https://w3c.github.io/webappsec/specs/mixedcontent/
  type: dfn
    text: embedding document
    text: strict mode
    text: block-all-mixed-content
    url: a-priori-insecure-url
      text: a priori insecure origin
      text: a priori insecure url
      text: a priori insecure
    url: potentially-secure-origin
      text: potentially secure origin
      text: potentially secure url
      text: potentially secure
spec: SECURE; urlPrefix: https://w3c.github.io/webappsec/specs/powerfulfeatures/
  type: dfn
    text: secure context
spec: STORAGE; urlPrefix: https://storage.spec.whatwg.org/
  type: interface
    text: StorageManager
spec: URL; urlPrefix: http://www.w3.org/TR/url/
  type: interface
    text: URL; url: concept-url
  type: attribute
    text: host; for: URL; url: concept-url-host
    text: path; for: URL; url: concept-url-path
    text: port; for: URL; url: concept-url-port
    text: scheme; for: URL; url: concept-url-scheme
spec: WORKERS; urlPrefix: http://www.w3.org/TR/workers/
  type: interface
    text: Worker
spec: SERVICE-WORKERS; urlPrefix: http://www.w3.org/TR/service-workers/
  type: dfn
    text: register; url: register-algorithm
    text: scope url; url: dfn-scope-url
    text: service worker registration; url: dfn-service-worker-registration
  type: method
    text: unregister(); for: ServiceWorkerRegistration; url: navigator-service-worker-unregister
spec: RFC5234; urlPrefix: https://tools.ietf.org/html/rfc5234
  type: dfn
    text: VCHAR; url: appendix-B.1
    text: WSP; url: appendix-B.1
spec: RFC5890; urlPrefix: https://tools.ietf.org/html/rfc5890
  type: dfn
    text: label; url: section-2.2
spec: RFC6265; urlPrefix: https://tools.ietf.org/html/rfc6265
  type: dfn
    text: canonicalized; url: section-5.1.2
    text: cookie store; url: section-5.3
    text: domain-match; url: section-5.1.3
spec: RFC6454; urlPrefix: https://tools.ietf.org/html/rfc6454
  type: dfn
    text: globally unique identifier; url: section-2.3
    text: origin; url: section-3.2
    text: the same; url: section-5
spec: RFC7234; urlPrefix: https://tools.ietf.org/html/rfc7234
  type: dfn
    text: network cache; url: section-2
spec: RFC7230; urlPrefix: https://tools.ietf.org/html/rfc7230
  type: dfn
    text: OWS; url: section-3.2.3
    text: BWS; url: section-3.2.3
    text: token; url: section-3.2.6
    text: quoted-string; url: section-3.2.6
    text: #rule; url: section-7
</pre>

<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  Web applications store data locally on a user's computer in order to provide
  functionality while the user is offline, and to increase performance when the
  user is online. These local caches have significant advantages for both users
  and developers, but present risks as well.

  A user's data is both sensitive and valuable; web developers ought to take
  reasonable steps to protect it. One such step would be to encrypt data before
  storing it. Another would be to remove data from the user's machine when it is
  no longer necessary (for example, when the user signs out of the application,
  or deletes their account).

  Site authors can remove data from a number of storage mechanisms via
  JavaScript, but others are difficult to deal with reliably. Consider cookies,
  for instance, which can be partially cleared via JavaScript access to
  <code>document.cookie</code>. <code>HttpOnly</code> cookies, however, can only
  be removed via a number of <code>Set-Cookie</code> headers in an HTTP
  response. This, of course, requires exhaustive knowledge of all the cookies
  set for a host, which can be complicated to ascertain. Cache is still harder;
  no imperative interface to a browser's network cache exists, period.

  This document defines a new mechanism to deal with removing data from these
  and other types of local storage, giving web developers the ability to clear
  out a user's local cache of data via the <a>Clear-Site-Data</a> HTTP response
  header.

  <h3 id="examples">Examples</h3>

  <h4 id="example-signout">Signing Out</h4>

  <div class="example">
    A user signs out of Super Secret Social Network via a CSRF-protected POST to
    <code>https://supersecretsocialnetwork.example.com/logout</code>, and the
    site author wishes to ensure that locally stored data is removed as a
    result.

    They can do so by sending the following HTTP header in the response:

    <pre>
      <a>Clear-Site-Data</a>: <a>*</a>
    </pre>
  </div>

  <h4 id="example-targeted">Targeted Clearing</h4>

  <div class="example">
    A user signs out of Megacorp Inc.'s site via a CSRF-protected POST to
    <code>https://megacorp.example.com/logout</code>. Megacorp has a large
    number of services available as subdomains, so many that it's not entirely
    clear which of them would be safe to clear as a response to a logout action.
    One option would be to simply clear everything, and deal with the fallout.
    Megacorp's CEO, however, once lost hours and hours of progress in "Irate
    Ibexes" due to inadvertent site-data clearing, and so refuses to allow such
    a sweeping impact to the site's users.

    The developers know, however, that the "Minus" application is certainly safe
    to clear out. They can target this specific subdomain by including a request
    to that subdomain as part of the logout landing page (ideally as a
    CORS-enabled, CSRF-protected POST):

    <pre>
      fetch("https://minus.megacorp.example.com/clear-site-data",
            {
                method: "POST",
                mode: "cors",
                headers: new Headers({
                    "CSRF": "[<em>insert sekrit token here</em>]"
                })
            });
    </pre>

    That endpoint would return proper CORS headers in response to that request's
    preflight, and would return the following header for the actual request:

    <pre>
      <a>Clear-Site-Data</a>: <a>*</a>; <a>includeSubdomains</a>
    </pre>
  </div>

  <h4 id="example-keepcookies">Keep Critical Cookies</h4>

  <div class="example">
    A user opts-out of interest-based advertising via a CSRF-protected POST to
    <code>https://ads-are-awesome.example.com/optout</code>. The site author
    wishes to remove DOM-accessible data which might contain tracking
    information, but needs to ensure that the opt-out cookie which the user has
    just received isn't wiped along with it.

    They can do so by sending the following HTTP header in the response, which
    includes all the types except for "<a>cookies</a>":

    <pre>
      <a>Clear-Site-Data</a>: <a>domStorage</a>; <a>executionContexts</a>; <a>cache</a>; <a>includeSubdomains</a>
    </pre>
  </div>

  <h4 id="example-killswitch">Kill Switch</h4>

  <div class="example">
    Super Secret Social Network's developers learn that the site was vulnerable
    to cross-site scripting attacks which allowed malicious parties to inject
    arbitrary code into its origin. They fixed the site, and added a strong
    Content Security Policy [[CSP2]] to mitigate the risk going forward, but
    they can't be entirely sure that clients are really back to a trustworthy
    state. Perhaps the attackers found a clever persistence mechanism?

    They can reduce the risk of a persistent client-side XSS by sending the
    following HTTP header in a response to wipe out local sources of data:

    <pre>
      <a>Clear-Site-Data</a>: <a>*</a>; <a>includeSubdomains</a>
    </pre>

    Note: Installing a Service Worker guarantees that a request will go out to
    a server every ~24 hours. That update ping would be a wonderful time to send
    a header like this one in case of catastrophe. [[SERVICE-WORKERS]]
  </div>

  <h3 id="goals">Goals</h3>

  Generally, the goal is to allow web developers more control over the data
  stored locally by a user agent for their origins. In particular, developers
  should be able to reliably ensure the following:

  1.  Data stored in an origin's client-side storage mechanisms like [[INDEXEDDB]],
      WebSQL, Filesystem, {{localStorage}}, and {{sessionStorage}} is cleared.
  2.  Cookies for an origin's host are removed [[!RFC6265]].
  3.  Web Workers (dedicated and shared) running for an origin are terminated.
  4.  Service Workers registered for an origin are terminated and deregistered.
  5.  Resources from an origin are removed from the user agent's local cache.
  6.  All of the above can be propagated to an origin's host's subdomains.
  7.  All of the above can be propagated to the HTTP version of an HTTPS origin.
  8.  None of the above can be bypassed by a maliciously active document that
      retains interesting data in memory, and rewrites it if it's cleared.
</section>

<section>
  <h2 id="clearing">Clearing Site Data</h2>

  Developers may instruct a user agent to clear various types of relevant data
  in two ways: an HTTP response header, and a JavaScript API:

  <h3 id="header">
    The <code>Clear-Site-Data</code> HTTP Response Header Field
  </h3>

  The <dfn><code>Clear-Site-Data</code></dfn> HTTP response header field
  sends a signal to the user agent that it ought to remove all data
  of a certain set of types. The header is represented by the following ABNF
  [[!RFC5234]]:

  <pre>
    Clear-Site-Data = 1#option
    <dfn>option</dfn> = <a>parameter</a> *( <a>OWS</a> ";" [ <a>OWS</a> <a>parameter</a> ] )
    <dfn>parameter</dfn> = <a>key</a> [ <a>BWS</a> "=" <a>value</a> ]
    <dfn>key</dfn> = <a>token</a>
    <dfn>value</dfn> = <a>token</a> / <a>quoted-string</a>
  </pre>

  Note: The <a>BWS</a>, <a>OWS</a>, <a>token</a>, and <a>quoted-string</a> rules
  as well as the <a>#rule</a> list extension are defined in [[RFC7230]].

  The <a>Clear-Site-Data</a> header's value is essentially a semicolon-delimited
  list of "<code>[key]=[value]</code>" pairs which define the kinds of data to
  be cleared for a given response.

  The following subsections define an initial set of known <a>parameter</a>
  components; future versions of this document may define additional
  <a>parameter</a> components: the ABNF above is intentionally generic and
  extensible to make room for these future values, and user agents MUST ignore
  unknown <a>parameter</a> components when parsing the header's value.

  <h4 id="cache-parameter">
    The <code>cache</code> parameter
  </h4>

  The <dfn><code>cache</code></dfn> parameter indicates that the server wishes
  to remove locally cached data associated with the <a>origin</a> of a
  particular <a>response</a>'s {{Response/url}}. This includes the <a>network
  cache</a>, of course, but will also remove data from various other caches
  which a user agent implements (prerendered pages, script caches, shader
  caches, etc.).

  The <a>value</a> component of this parameter is currently ignored, if present.

  Implementation details are in [[#clear-cache]], as part of the larger
  [[#clear-response]] and [[#clear-api]] algorithms.

  <div class="example">
    When delivered with a response from <code>https://example.com/clear</code>,
    the following header will cause caches associated with the origin
    <code>https://example.com</code> to be cleared:

    <pre>
      <a>Clear-Site-Data</a>: <a>cache</a>
    </pre>
  </div>

  <h4 id="cookies-parameter">
    The <code>cookies</code> parameter
  </h4>

  The <dfn><code>cookies</code></dfn> parameter indicates that the server wishes
  to remove cookies associated with the <a>origin</a> of a particular
  <a>response</a>'s {{Response/url}}. This includes the <a>network cache</a>, of
  course, but will also remove data from various other caches which a user agent
  implements (prerendered pages, script caches, shader caches, etc.).

  The <a>value</a> component of this parameter is currently ignored, if present.

  Implementation details are in [[#clear-cache]], as part of the larger
  [[#clear-response]] and [[#clear-api]] algorithms.

  <div class="example">
    When delivered with a response from <code>https://example.com/clear</code>,
    the following header will cause cookies associated with the origin
    <code>https://example.com</code> to be cleared:

    <pre>
      <a>Clear-Site-Data</a>: <a>cookies</a>
    </pre>
  </div>

  <h4 id="domStorage-parameter">
    The <code>domStorage</code> parameter
  </h4>

  The <dfn><code>domStorage</code></dfn> parameter indicates that the server
  wishes to remove locally stored data associated with the <a>origin</a> of a
  particular <a>response</a>'s {{Response/url}}. This includes storage
  mechansims such as ({{localStorage}}, {{sessionStorage}}, [[INDEXEDDB]],
  [[WEBDATABASE]], etc), as well as tangentially related mechainsm such as
  <a>service worker registrations</a>.

  The <a>value</a> component of this parameter is currently ignored, if present.
 
  Implementation details are in [[#clear-dom]], as part of the larger
  [[#clear-response]] and [[#clear-api]] algorithms.

  <div class="example">
    When delivered with a response from <code>https://example.com/clear</code>,
    the following header will cause DOM-accessible storage for the origin 
    <code>https://example.com</code> to be cleared:

    <pre>
      <a>Clear-Site-Data</a>: <a>domStorage</a>
    </pre>
  </div>

  ISSUE: Probably should rename this to "storage".

  <h4 id="executionContexts-parameter">
    The <code>executionContexts</code> parameter
  </h4>

  The <dfn><code>executionContexts</code></dfn> parameter indicates that the
  server wishes to neuter and reload execution contexts currently rendering the
  <a>origin</a> of a particular <a>response</a>'s {{Response/url}}.

  The <a>value</a> component of this parameter is currently ignored, if present.

  Implementation details are in [[#neuter-contexts]], as part of the larger
  [[#clear-response]] and [[#clear-api]] algorithms.

  <div class="example">
    When delivered with a response from <code>https://example.com/clear</code>,
    the following header will cause execution contexts displaying the origin 
    <code>https://example.com</code> to be neutered and reloaded:

    <pre>
      <a>Clear-Site-Data</a>: <a>executionContexts</a>
    </pre>
  </div>

  <h4 id="includeSubdomains-parameter">
    The <code>includeSubdomains</code> parameter
  </h4>

  The <dfn><code>includeSubdomains</code></dfn> parameter expands the scope of
  the storage type parameters to include any origin whose {{URL/host}} is a
  subdomain of the <a>response</a>'s {{Response/url}}'s {{URL/host}}.

  Implementation details are included as part of the larger [[#clear-response]]
  and [[#clear-api]] algorithms.

  <div class="example">
    When delivered with a response from <code>https://example.com/clear</code>,
    the following header will cause caches associated with the origins
    <code>https://example.com</code> and
    <code>https://anythingelse.example.com</code> to be cleared:

    <pre>
      <a>Clear-Site-Data</a>: <a>cache</a>; <a>includeSubdomains</a>
    </pre>
  </div>

  <h4 id="wildcard-parameter">
    The <code>*</code> parameter
  </h4>

  The <dfn><code>*</code></dfn> parameter is syntactic sugar which includes all
  storage type parameters. That is:
  
  <pre>
    <a>Clear-Site-Data</a>: <a>*</a>
  </pre>
  
  has the same meaning as:
  
  <pre>
    Clear-Site-Data: <a>cache</a>; <a>cookies</a>; <a>domStorage</a>; <a>executionContexts</a>
  </pre>

  <h3 id="dom-api">JavaScript API</h3>

  ISSUE: This might live more cleanly in [[STORAGE]].

  <div class="example">
    Megacorp, Inc. wants to remove data in response to a user's activity on
    their site. They can execute the following JavaScript to clear all the
    relevant data for a user:

    <pre>
      navigator.storage.<a method>clear()</a>;
    </pre>

    If they only wished to clear the otherwise inaccessible cache for the
    current origin and all subdomains:

    <pre>
      navigator.storage.<a method>clear</a>({
        <a dict-member>types</a>: [ "cache" ],
        <a dict-member>includeSubdomains</a>: true
      });
    </pre>
  </div>

  <pre class="idl">
    enum StorageClearType {
      "cache",
      "cookies",
      "domStorage",
      "executionContexts"
    };

    dictionary StorageClearOptions {
      sequence&lt;StorageClearType&gt; types;
      boolean includeSubdomains = false;
    };

    partial interface StorageManager {
      Promise&lt;void&gt; clear(StorageClearOptions options);
    };
  </pre>
  <dl dfn-for="StorageManager">
    <dt><dfn method lt="clear(options)">clear(options)</dfn></dt>
    <dd>
      Clears data based on the values in the <var>options</var> argument.
      Returns a Promise that resolves when clearing is complete. If no
      {{StorageClearOptions/types}} are specified, all data types will be
      cleared.

      <pre class="argumentdef" for="StorageManager/clear(options)">
        options: The data to clear.
      </pre>
    </dd>
  </dl>

  <h3 id="fetch-integration">Fetch Integration</h3>

  ISSUE: Monkey patching! Talk with Anne.

  If the <a><code>Clear-Site-Data</code></a> header is present in an HTTP
  <a>response</a>, then data MUST be cleared before rendering the response to
  the user. That is, before step #9 in the current <a>main fetch</a> algorithm,
  execute the following step:

  9.  If <var>response</var>'s <a>header list</a> contains a header named
      <a><code>Clear-Site-Data</code></a>, then execute [[#clear-response]] on
      <var>response</var>.

  Note: This happens <em>after</em> <code>Set-Cookie</code> headers are
  processed. If we clear cookies, we clear all of them. This is intentional, as
  removing only certain cookies might leave an application in an indeterminate
  and vulnerable state. Removing specific cookies is best done via expiration 
  using the <code>Set-Cookie</code> header.
<section>

<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="parsing">Parsing</h3>

  <h4 id="get-types">
    Which data types ought to be removed for <var>response</var>?
  </h4>

  1.  If <var>response</var> does not contain a
      <a><code>Clear-Site-Data</code></a> header, return an empty list.

  2.  Let <var>parameters</var> be the list of <a>parameter</a> components in
      the value of <var>response</var>'s <a><code>Clear-Site-Data</code></a>
      header.

  3.  If <var>parameters</var> contains a <a>parameter</a> whose <a>key</a> is
      <a><code>*</code></a>:

      1. Append <code>cache</code>, <code>cookies</code>,
         <code>domStorage</code>, and <code>executionContexts</code> to
         <var>remove</var>.

      2. Return <var>remove</var>.

  3.  Otherwise, let <var>remove</var> be an empty list.

  4.  For each <var>parameter</var> in <var>parameters</var>:
  
      1.  If <var>parameter</var>'s <a>key</a> is <a><code>cache</code></a>,
          <a><code>cookies</code></a>, <a><code>domStorage</code></a>, or
          <a><code>executionContexts</code></a>, <a><code>cache</code></a>
          append <var>parameter</var>'s <a>key</a> to <var>remove</var>.

      2.  Otherwise, ignore <var>parameter</var>.

  5.  Return <var>remove</var>.

  <h4 id="should-include-subdomains">
    Should subdomains' data be cleared for <var>response</var>
  </h4>

  1.  If <var>response</var> does not contain a
      <a><code>Clear-Site-Data</code></a> header, return <dfn><code>Exclude
      Subdomains</code></dfn>.

  2.  Let <var>parameters</var> be the list of <a>parameter</a> components in
      the value of <var>response</var>'s <a><code>Clear-Site-Data</code></a>
      header.

  3.  If <var>parameters</var> contains a <a>parameter</a> whose <a>key</a> is
      <a><code>includeSubdomains</code></a>, return <dfn><code>Include
      Subdomains</code></dfn>.
     
  4.  Otherwise, return <code>Exclude Subdomains</code>.

  <h4 id="matches-origin">
    Does <var>origin</var> match <var>origin to clear</var> and
    <var>subdomain state</var>
  </h4>

  Given an origin, the origin to clear, and the "include subdomains"
  flag, return <dfn><code>Matches</code></dfn> or <dfn><code>Does Not
  Match</code></dfn>.

  1.  If either <var>origin</var> or <var>origin to clear</var> are <a>globally
      unique identifiers</a>, return <code>Does Not Match</code>.

  2.  If <var>origin</var> is <a>the same</a> as <var>origin to clear</var>,
      return <code>Matches</code>.

  3.  If <var>subdomain state</var> is <a><code>Exclude Subdomains</code></a>,
      return <code>Does Not Match</code>.

  4.  Let <var>labels to clear</var> be the {{URL/host}} component of <var>origin
      to clear</var> split into <a>labels</a>, and <var>labels</var> be the
      {{URL/host}} component of <var>origin</var>, split into <a>labels</a>.

  5.  If <var>labels</var> does not have more entries than <var>labels to
      clear</var>, return <code>Does Not Match</code>.

  6.  While <var>labels to clear</var> is not empty:

      1.  If the final entry of <var>labels to clear</var> does not exactly
          match the final entry of <var>labels</var>, return <code>Does Not
          Match</code>.

      2.  Remove the final entry of <var>labels to clear</var>, and of
          <var>labels</var>.

  7.  Return <code>Matches</code>.

  <h3 id="clear-response">
    Clear data for <var>response</var>
  </h3>

  Given a <a>response</a> (<var>response</var>), this algorithm parses the
  <a><code>Clear-Site-Data</code></a> header to determine what needs to be
  cleared, which origins are affected, and then executes those requests.

  1.  If <var>response</var>'s {{URL}} is <a><i lang="la">a priori</i>
      insecure</a>, skip the remaining steps of this algorithm.

      ISSUE: Some have suggested that this might not be a restriction we want
      (see
      <a href="https://lists.w3.org/Archives/Public/public-webappsec/2015Jun/0032.html">Martin
      Thomson's public-webappsec post on the topic</a>, for example).

  2.  Let <var>types</var> be the result of [[#get-types]] executed on
      <var>response</var>.

  3.  Let <var>subdomain state</var> be the result of
      [[#should-include-subdomains]] executed on <var>response</var>.

  4.  Execute [[#clear-internal]] on <var>types</var>, <var>response</var>'s
      {{Response/url}}'s <a>origin</a>, and <var>subdomain state</var>.

  Note: Especially given the cross-context implications, user agents are
  are encouraged to give web developers some mechanism by which the clearing
  operation can be debugged. This might take the form of a console message or
  timeline entry indicating success.

  <h3 id="clear-api">
    Clear data for <var>storageRequestOptions</var>
  </h3>

  Given a {{StorageClearOptions}} (<var>options</var>), this algorithm
  determines what needs to be cleared, returns a Promise, and executes the
  request asynchronously.

  1.  If the <a>incumbent settings object</a> is not a <a>secure context</a>,
      return a <code>Promise</code> rejected with
      <code>NotSupportedError</code>.

  2.  Let <var>promise</var> be a newly created <code>Promise</code> object.

  3.  Return <var>promise</var>, and execute the remaining steps asynchronously.

  4.  Let <var>subdomain state</var> be <a><code>Include Subdomains</code></a>
      if <var>options</var>' {{StorageClearOptions/includeSubdomains}} property
      is <code>true</code>, and <a><code>Exclude Subdomains</code></a>
      otherwise.

  5.  Let <var>types</var> be an empty list.

  6.  If <var>options</var>' {{StorageClearOptions/types}} is an empty sequence:

      1. Append <code>cache</code>, <code>cookies</code>,
         <code>domStorage</code>, and <code>executionContexts</code> to
         <var>types</var>.

  7.  Otherwise, for each {{StorageClearType}} <var>type</var> in
      <var>options</var>' {{StorageClearOptions/types}} property:

      1. Append <var>type</var> to <var>types</var>.

  8.  Execute [[#clear-internal]] on <var>types</var>, the <a>incumbent
      settings object</a>'s <a>origin</a>, and <var>subdomain state</var>.

  9.  Resolve <var>promise</var> with <code>undefined</code>.

  <h3 id="clear-internal">
    Clear <var>types</var> for <var>origin</var> with <var>subdomain
    state</var>
  </h3>

  1.  If <var>types</var> contains "<code>executionContexts</code>", execute
      [[#neuter-contexts]] on <var>origin</var>, with <var>subdomain
      state</var>.

  2.  If <var>types</var> contains "<code>cookies</code>", execute
      [[#clear-cookies]] on <var>origin</var>, with <var>subdomain state</var>.

  3.  If <var>types</var> contains "<code>domStorage</code>", execute
      [[#clear-dom]] on <var>origin</var>, with <var>subdomain state</var>.

  4.  If <var>types</var> contains "<code>cache</code>", execute
      [[#clear-cache]] on <var>origin</var>, with <var>subdomain state</var>.

  5.  If <var>types</var> contains "<code>executionContexts</code>", execute
      [[#reload-contexts]] on <var>origin</var>, with <var>subdomain
      state</var>.

  <h4 id="neuter-contexts">
    Neuter browsing contexts matching <var>origin</var> with
    <var>subdomain state</var>
  </h4>

  Given an <a>origin</a> (<var>origin</var>) and a <var>subdomain state</var>
  of either <a><code>Include Subdomains</code></a> or <a><code>Exclude
  Subdomains</code></a>, this algorithm walks through the set of <a>browsing
  contexts</a> which the user agent knows about, and sandboxes each in order
  to prevent them from recreating cleared data (from in-memory JavaScript
  variables, for instance). Once data is cleared, the affected browsing
  contexts will be hard-reloaded, as defined in [[#reload-contexts]]:

  1.  For each <var>context</var> in the user agent's set of <a>browsing
      contexts</a>:

      1.  Let <var>document</var> be <var>context</var>'s <a>active
          document</a>.

      2.  While <var>document</var> is <a>an <code>iframe srcdoc</code>
          document</a>, let <var>document</var> be the <a>active document</a>
          of <var>document</var>'s <a>browsing context container</a>.

      3.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>context</var>'s <a>origin</a>, <var>origin</var>, and
          <code>subdomain state</code>:

          1.  <a>Parse a sandboxing directive</a> using the empty string as
              the <var>input</var>, and <var>document</var>'s <a>active
              sandboxing flag set</a> as the <var>output</var>.

  <h4 id="reload-contexts">
    Reload browsing contexts matching <var>origin</var> with
    <var>subdomain state</var>
  </h4>

  Given an <a>origin</a> (<var>origin</var>) and a <var>subdomain state</var>
  of either <a><code>Include Subdomains</code></a> or <a><code>Exclude
  Subdomains</code></a>, this algorithm walks through the set of <a>browsing
  contexts</a> which the user agent knows about and reloads each of them:

  1.  For each <var>context</var> in the user agent's set of <a>browsing
      contexts</a>:

      1.  Let <var>document</var> be <var>context</var>'s <a>active
          document</a>.

      2.  While <var>document</var> is <a>an <code>iframe srcdoc</code>
          document</a>, let <var>document</var> be the <a>active document</a>
          of <var>document</var>'s <a>browsing context container</a>.

      3.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>context</var>'s <a>origin</a>, <var>origin</var>, and
          <code>subdomain state</code>:

          1.  Navigate <var>context</var> to <var>document</var>'s {{URL}} with
              <a>replacement enabled</a> and <a>exceptions enabled</a>. The
              <a>source browsing context</a> is <var>context</var>. This is a
              <a>reload-triggered navigation</a>.
          
  <h4 id="clear-cache">
    Clear cache for <var>origin</var> with <var>subdomain state</var>
  </h4>

  Given an <a>origin</a> (<var>origin</var>) and a <var>subdomain state</var>
  of either <a><code>Include Subdomains</code></a> or <a><code>Exclude
  Subdomains</code></a>, this algorithm removes data from the user agent's
  local caches that matches the origin and subdomain state.

  1.  Let <var>host</var> be <var>origin</var>'s {{URL/host}},
      <a>canonicalized</a> as per Section 5.1.2 of [[!RFC6265]].

  2.  If <var>subdomain state</var> is <a><code>Include Subdomains</code></a>,
      then let <var>cache list</var> be the set of entries from the <a>network
      cache</a> whose <code>target URI</code>'s {{URL/host}}
      <a>domain-matches</a> <var>host</var> when <a>canonicalized</a> as per
      Section 5.1.2 of [[!RFC6265]]

  3.  Otherwise, <var>subdomain state</var> is <a><code>Exclude
      Subdomains</code></a>, so let <var>cache list</var> be the set of
      entries from the <a>network cache</a> whose <code>target URI</code>
      {{URL/host}} is identical to <var>host</var> when <a>canonicalized</a> as
      per Section 5.1.2 or [[!RFC6265]].

  4.  Remove each <var>entry</var> in <var>cache list</var> from the <a>network
      cache</a>.

  5.  If a user agent implements caches beyond a pure <a>network cache</a>, it
      MUST remove all entries from those caches which match <var>origin</var>
      and <var>subdomain state</var>.

      ISSUE: We're dealing with the network cache here, as defined in
      [[!RFC7234]], but that's not nearly everything a user agent caches. How
      hand-wavey with the vendor-specific section can we be? For instance,
      Chrome clears out prerendered pages, script caches, WebGL shader caches,
      WebRTC bits and pieces, address bar suggestion caches, various networking
      bits that aren't representations (HSTS/HPKP, SCDH, etc.). Perhaps
      [[STORAGE]] will make this clearer?

  <h4 id="clear-cookies">
    Clear cookies for <var>origin</var> with <var>subdomain state</var>
  </h4>

  Given an <a>origin</a> (<var>origin</var>) and a <var>subdomain state</var>
  of either <a><code>Include Subdomains</code></a> or <a><code>Exclude
  Subdomains</code></a>, this algorithm removes cookies from the user agent's
  <a>cookie store</a> whose <code>domain</code> attribute matches the origin
  and subdomain state.

  Note: This algorithm assumes that the user agent has implemented a <a>cookie
  store</a> (as discussed in Section 5.3 of [[!RFC6265]]), which offers the
  ability to retrieve a list of cookies by host, and to remove individual
  cookies.

  1.  Let <var>host</var> be <var>origin</var>'s {{URL/host}},
      <a>canonicalized</a> as per Section 5.1.2 of [[!RFC6265]].

  2.  If <var>subdomain state</var> is <a><code>Include Subdomains</code></a>,
      then let <var>cookie list</var> be the set of cookies from the <a>cookie
      store</a> whose <code>domain</code> attribute is <a>domain-matched</a> by
      <var>host</var>.

      Note: The direction of the matching is important. If
      <code>subdomain.example.com</code> delivers the
      <a><code>Clear-Site-Data</code></a> header and includes subdomains, then
      cookies for <code>.another.subdomain.example.com</code> will be cleared,
      but cookies for <code>.example.com</code> will not.

  3.  Otherwise, <var>subdomain state</var> is <a><code>Exclude
      Subdomains</code></a>, so let <var>cookie list</var> be the set of
      cookies from the <a>cookie store</a> whose <code>domain</code> attribute
      is identical to <var>host</var>.

  4.  Remove each <var>cookie</var> in <var>cookie list</var> from the <a>cookie
      store</a>.

  <h4 id="clear-dom">
    Clear DOM-accessible storage for <var>origin</var> with
    <var>subdomain state</var>
  </h4>

  1.  For each <var>area</var> in the user agent's set of <a>local storage
      areas</a> [[!HTML]]:

      1.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>area</var>'s <a>origin</a>, <var>origin</var>, and
          <code>subdomain state</code>:

          1.  Execute {{Storage/clear()}} on the {{Storage}} object associated
              with <var>area</var>.

  2.  For each <var>area</var> in the user agent's set of <a>session storage
      areas</a> [[!HTML]]:

      1.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>area</var>'s <a>origin</a>, <var>origin</var>, and
          <code>subdomain state</code>:

          1.  Execute {{Storage/clear()}} on the {{Storage}} object associated
              with <var>area</var>.

  3.  For each <var>database</var> in the user agent's set of Indexed
      Databases [[!INDEXEDDB]]:

      1.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>database</var>'s <a>origin</a>, <var>origin</var>,
          and <code>subdomain state</code>:

          1.  Set <var>database</var>'s <a>delete pending</a> flag to
              <code>true</code>.

          2.  For each <var>connection</var> in the set of all {{IDBDatabase}}
              objects connected to <var>database</var>:

              1.  Execute the <a>database closing steps</a> on
                  <var>connection</var>.

          3.  Execute the <a>database deletion steps</a> on
              <var>database</var>, passing in <var>database</var>'s
              <a>origin</a> and name.

  4.  For each <var>database</var> in the user agent's set of WebSQL
      databases [[!WEBDATABASE]]:

      1.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>database</var>'s <a>origin</a>, <var>origin</var>,
          and <code>subdomain state</code>:

          1. Delete <var>database</var>.

             ISSUE: The [[WEBDATABASE]] spec is fairly unhelpful here with
             regard to deletion details.

  5.  For each <var>registration</var> in the user agent's set of
      <a>registered</a> <a>service worker registrations</a>:

      1.  If [[#matches-origin]] returns <a><code>Matches</code></a> when
          executed on <var>registration</var>'s <a>scope URL</a>'s
          <a>origin</a>, <var>origin</var>, and <code>subdomain state</code>:

          1.  Execute {{ServiceWorkerRegistration/unregister()}} on
              <var>registration</var>.

  ISSUE: We still need to spell out Filesystems, Dedicated Workers, Shared
  Workers, etc. (This isn't an exhaustive list. We should fix that too.)

  ISSUE: How do we say something about plugins here? Point out to
  <a href="https://wiki.mozilla.org/NPAPI:ClearSiteData">NPP_ClearSiteData</a>?
</section>

<section>
  <h2 id="privacy">Privacy Considerations</h2>

  <h3 id="user-vs-author">Web developers control the timing.</h3>

  If triggered at appropriate times, <a><code>Clear-Site-Data</code></a> can
  increase a user's privacy and security by clearing sensitive data from their
  user agent. However, note that the web developer (and <em>not</em> the user)
  is in control of when the clearing event is triggered. Even assuming a
  non-malicious site author, users can't rely on data being cleared at any
  particular point, nor are users in control of what data types are cleared.

  If a user wishes to ensure that site data is indeed cleared at some specific
  point, they ought to rely on the data-clearing functionality offered by their
  user agent.

  At a bare minimum, user agents OUGHT TO (in the [[RFC6919]] sense of the
  words) offer the same functionality to users that they offer to web
  developers. Ideally, they will offer significantly more than we can offer at
  a platform level (clearing browsing history, for example).

  <h3 id="remnants">Remnants of data on disk.</h3>

  While <a><code>Clear-Site-Data</code></a> triggers a clearing event in a
  user's agent, it is difficult to make promises about the state of a user's
  disk after a clearing event takes place. In particular, note that it is up
  to the user agent to ensure that all traces of a site's date is actually
  removed from disk, which can be a herculean task (consider virtual memory,
  as a good example of a larger issue).

  In short, most user agents implement data clearing as "best effort", but
  can't promise an exhaustive wipe.

  If a user wishes to ensure that site data does not remain on disk, the best
  way to do so is to use a browsing mode that promises not to intentionally
  write data to disk (Chrome's "Incognito", Internet Explorer's "InPrivate",
  etc). These modes will do a better job of keeping data off disk, but are
  still subject to a number of limitations at the edges.
</section>

<section>
  <h2 id="iana-considerations">IANA Considerations</h2>

  The permanent message header field registry should be updated
  with the following registration: [[!RFC3864]]

  <h3 id="iana-clear-site-data">
    Clear-Site-Data
  </h3>

  <dl>
    <dt>Header field name</dt>
    <dd>Clear-Site-Data</dd>

    <dt>Applicable protocol</dt>
    <dd>http</dd>

    <dt>Status</dt>
    <dd>standard</dd>

    <dt>Author/Change controller</dt>
    <dd>W3C</dd>

    <dt>Specification document</dt>
    <dd>This specification (See [[#header]])</dd>
  </dl>

<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  Michal Zalewski proposed a variant of this concept, and Mark Knichel helped
  refine the details.
</section>
