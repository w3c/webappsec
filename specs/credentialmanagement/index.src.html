<h1>Credential Management</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/credentialmanagement/
Shortname: CREDENTIAL
Level: 1
Editor: Mike West, Google Inc., mkwst@google.com
Group: webappsec
Abstract: This specification describes an imperative API enabling a website to request a user's credentials in order to sign them in, and to help the user agent correctly store user credentials for future use.
Version History: https://github.com/w3c/webappsec/commits/master/specs/credentialmanagement/index.src.html
!Use Cases: <a href="https://w3c.github.io/webappsec/usecases/credentialmanagement/">https://w3c.github.io/webappsec/usecases/credentialmanagement/</a>
Indent: 2
</pre>

<pre class="anchors">
type: dfn
  urlPrefix: http://www.w3.org/TR/html5/
    urlPrefix: webappapis.html
      text: responsible document
      text: incumbent settings object
    urlPrefix: infrastructure.html
      text: resolve a url
    urlPrefix: forms.html
      text: autocomplete
    urlPrefix: browsers.html
      text: allowed to show a popup
      text: browsing context
      text: top-level browsing context
      text: nested browsing context
      text: active document
  urlPrefix: https://tools.ietf.org/html/rfc6454
    text: origin; url: section-3.2
    text: ASCII serialization of an origin; url: section-6.2
    text: ASCII serialization; url: section-6.2
  urlPrefix: https://w3c.github.io/webappsec/specs/mixedcontent/
    text: a priori insecure origin
    text: a priori insecure url
  urlPrefix: https://w3c.github.io/webappsec/specs/powerfulfeatures/
    text: sufficiently secure context
    text: is Document a sufficiently secure context?; url: document-sufficiently-secure
  urlPrefix: https://fetch.spec.whatwg.org/
    text: extracting a MIME type; url: concept-header-extract-mime-type
  urlPrefix: https://w3c.github.io/webappsec/specs/content-security-policy/
    text: form-action; url: directive-form-action
    text: connect-src; url: directive-connect-src
    text: frame-src; url: directive-frame-src
type: element-attr 
  urlPrefix: http://www.w3.org/TR/html5/
    urlPrefix: forms.html
      text: autocomplete; for: form; url: attr-form-autocomplete
type: interface
  urlPrefix: https://www.w3.org/TR/html5/webappapis.html
    text: Navigator
  urlPrefix: https://xhr.spec.whatwg.org/
    text: XMLHttpRequest; url: interface-xmlhttprequest
    text: FormData; url: interface-formdata
  urlPrefix: https://heycam.github.io/webidl/
    text: DOMString; url: idl-DOMString
    text: boolean; url: idl-boolean
type: method
  urlPrefix: http://www.w3.org/TR/webmessaging/
    text: postMessage(); for: window; url: dom-window-postmessage
type: constructor
  urlPrefix: https://xhr.spec.whatwg.org/
    text: XMLHttpRequest(); for: XMLHttpRequest; url: dom-xmlhttprequest
</pre>


<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="introduction">Introduction</h2>

  <em>This section is not normative.</em>

  Signing into websites is more difficult than it should be. The user agent is
  in a unique position to improve the experience in a number of ways, and most
  modern user agents have recognized this by providing some measure of
  credential management natively in the browser. Users can save usernames and
  passwords for websites, and those <a>credentials</a> are autofilled into
  sign-in forms with varying degrees of success.

  The <code><a element-attr>autocomplete</a></code> attribute offers a
  declarative mechanism by which websites can work with user agents to improve
  the latter's ability to detect and fill sign-in forms by marking specific
  fields as "username" or "password", and user agents implement a wide variety
  of detection heuristics to work with websites which haven't taken the time to
  provide this detail in markup.

  While this combination of heuristic and declarative detection works relatively
  well, the status quo leaves some large gaps where detection is problematic.
  Sites with uncommon sign-in mechanisms (submitting credentials via
  {{XMLHttpRequest}} [[XMLHTTPREQUEST]], for instance) are difficult to reliably
  detect, as is the increasingly common case in which users wish to authenticate
  themselves using a <a>federated identity provider</a>. Allowing websites to
  more directly interact with the user agent's credential manager would allow
  the credential manager to be more accurate on the one hand, and to assist
  users with federated sign-in on the other.

  These use cases are explored in more detail in [[#use-cases]] and in
  <a href="../usecases/">Credential Management: Use Cases and Requirements</a>;
  this specification attempts to address many of the requirements that document
  outlines by defining a Credential Manager API which a website can use to
  request <a>credentials</a> for a user, and to notify the user agent that the
  user successfully signed in, failed to sign in, or signed out.

  Note: The API defined here is intentionally small and simple: it does not
  intend to provide authentication in and of itself, but is limited to providing
  an interface to the existing credential managers implemented by existing user
  agents. That functionality is valuable <em>right now</em>, without significant
  effort on the part of either vendors or authors. There's certainly quite a bit
  more which could be done, of course. See [[#future-work]] for some thoughts
  we've punted for now, but which could be explored in future iterations of this
  API.

  <section>
    <h3 id="use-cases">Use Cases</h3>

    Modern user agents generally offer users the capability to save passwords
    when signing into a website, and likewise offer the capability to fill those
    passwords into sign-in forms fully- or semi-automatically when users return
    to a website. From the perspective of a website, this behavior is completely
    invisible: the website doesn't know that passwords have been stored, and it
    isn't notified that passwords have been filled. This is both good and bad.
    On the one hand, a user agent's password manager works regardless of whether
    or not a site cooperates, which is excellent for users. On the other, the
    password managers' behaviors are a fragile and proprietary hodgepodge of
    heuristics meant to detect and fill sign-in forms, password change forms,
    and etc.

    A few problems with the status quo stand out as being particularly
    problematic:

    <ul>
      <li>
        User agents have an incredibly difficult time helping users with
        federated identity providers. While detecting a username/password
        form submission is fairly straightforward, detecting sign-in via a
        third-party is quite difficult to reliably do well. It would be nice
        if a website could help the user agent understand the intent behind the
        redirects associated with a typical federated sign-in action.
      </li>
      <li>
        Likewise, user agents struggle to detect more esoteric sign-in
        mechanisms than simple username/password forms. Authors increasingly
        asynchronously sign users in via {{XMLHttpRequest}} or similar
        mechanisms in order to improve the experience and take more control over
        the presentation. This is good for users, but tough for user agents to
        integrate into their password managers. It would be nice if a website
        could help the user agent make sense of the sign-in mechanism they
        choose to use.
      </li>
      <li>
        While signing into a website with a username and password is fairly well
        supported, creating a new account on a website is more or less left up
        to the user. The user agent has a good deal of information which could
        help the user create an account, of course: for instance, it knows
        whether the user has stored passwords for federated identity providers
        which the website might support, it could help the user fill in commonly
        used elements like email addresses, and so on.
      </li>
      <li>
        Finally, changing passwords is less well-suppported than it could be if
        the website explicitly informed the user agent that credentials had
        changed.
      </li>
    </ul>
  </section>

  <section>
    <h3 id="introduction-examples">Examples</h3>

    <h4 id="examples-local-signin">Local Sign-in</h4>

    A website that supports only username/password pairs can request
    credentials, and use them in existing sign-in forms:

    <div class="example">
      <pre>
        if (!navigator.<a attribute>credentials</a>) {
          // Sadness! Return early.
          return;
        }

        navigator.<a attribute>credentials</a>.<a idl>request()</a>.then(
            function(credential) {
              if (!credential) {
                // The user either doesn't have credentials for this site, or
                // refused to share them. Insert some code here to show a basic
                // login form (or, ideally, do nothing, since this API should
                // really be progressive enhancement on top of an existing form).
                return;
              }

              var xhr = new <a>XMLHttpRequest()</a>;
              xhr.open("POST", "https://example.com/loginEndpoint");
              xhr.onreadystatechange = function () {
                if (this.readyState != this.DONE)
                  return;

                var loginSucceeded = // Process response: if login succeeded, yay! If not, boo!;
                if (loginSucceeded) {
                  navigator.<a attribute>credentials</a>.<a idl lt="notifySignedIn()">notifySignedIn</a>(credential);
                  // Notify the user that signin succeeded! Do amazing, signed-in things!
                } else {
                  navigator.credentials.<a idl lt="notifyFailedSignIn()">notifyFailedSignIn</a>(credential);
                  // Notify the user that signin failed, and fall back to the usual experience.
                }
              };

              xhr.send(credential.<a attribute>formData</a>);
            });
      </pre>
    </div>

    <h4 id="examples-federated-signin">Federated Sign-in</h4>

    A website that supports <a>federated identity providers</a> can request
    credentials, and use them to kick off the sign-in flow for the user's
    chosen provider:

    <div class="example">
      <pre>
        if (!navigator.<a attribute>credentials</a>) {
          // Sadness! Return early.
          return;
        }

        navigator.<a attribute>credentials</a>.<a idl lt="request()">request</a>({
          "<a idl for="CredentialRequestOptions">federations</a>": [ "https://federation.com" ]
        }).then(
            function(credential) {
              if (!credential) {
                // The user either doesn't have credentials for this site, or
                // refused to share them. Insert some code here to show a basic
                // login form (or, ideally, do nothing, since this API should
                // really be progressive enhancement on top of an existing form).
                return;
              }

              if (credential instanceof <a idl>FederatedCredential</a>) {
                switch (credential.<a idl for="FederatedCredential">federation</a>) {
                  // Do something specific for each supported federation.
                }
              } else {
                var xhr = new <a>XMLHttpRequest()</a>;
                xhr.open("POST", "https://example.com/loginEndpoint");
                xhr.onreadystatechange = // Success handler from first example.
                xhr.send(credential.<a attribute>formData</a>);
              }
            });
      </pre>

      Note: This API is focused on a sign-in workflow, but could potentially
      be useful for federated <strong>sign-up</strong> flows as well.
    </div>

    <h4 id="examples-post-signin">Post-sign-in Confirmation</h4>

    To ensure that credentials are persisted correctly, it may be useful for a
    website to tell the credential manager that sign-in succeeded.

    <div class="example">
      After navigation, the website won't (shouldn't) have access to the
      password, but can rely on the user agent to have retained a pending
      credential:

      <pre>
        if (navigator.<a attribute>credentials</a>)
          navigator.<a attribute>credentials</a>.<a idl lt="notifySignedIn()">notifySignedIn</a>(navigator.<a attribute>credentials</a>.<a idl>pending</a>);
      </pre>
    </div>

    <div class="example">
      If we haven't navigated (perhaps sign-in happened via {{XMLHttpRequest}}),
      then we can explain exactly which credentials were used:

      <pre>
        if (navigator.<a attribute>credentials</a>) {
          navigator.<a attribute>credentials</a>.<a idl lt="notifySignedIn()">notifySignedIn</a>(
            new <a idl>LocalCredential</a>("username", "hunter1")
          );
        }
      </pre>
    </div>

    <div class="example">
      If we're using a <a>federated identity provider</a>:

      <pre>
        if (navigator.<a attribute>credentials</a>) {
          navigator.<a attribute>credentials</a>.<a idl lt="notifySignedIn()">notifySignedIn</a>(
            new <a idl>FederatedCredential</a>("username", "https://federation.com")
          );
        }
      </pre>
    </div>

    <h4 id="examples-sign-up">Sign-Up</h4>

    The "federated sign-in" mechanism can be reused for "sign-up" with no
    modifications: if the user has a credential from a supported federated
    identity provider, it could be offered to the user via the same request
    mechanism.

    <h4 id="examples-change-password">Change Password</h4>

    The "Local Sign-In" mechanism can be reused for "password change" with no
    modifications: if the user changes her credentials, the website can notify
    the user agent that she's successfully signed in with new credentials. The
    user agent can then update the credentials it stores.
  </section>

  <section>
    <h3 id="existing-solutions">
      Haven't we done this before? What about [<em>insert technology here</em>]?
    </h3>

    <h4 id="existing-solutions-browserid">BrowserID/Persona</h4>

    BrowserID is a proposal for an API which allows websites to request an
    assertion of a user's email address ownership. [[BROWSERID]]

    The API specified here does not attempt to assert the user's identity
    directly: it only provides a more direct interface to the user agent's
    <a>credential store</a>. Assertions about identity would still rely on
    <a>federated identity provider</a>'s particular SDKs and workflows.

    BrowserID is complementary to this API, and could be tacked onto the
    {{FederatedCredential}} flow at some point in the future. For example, a
    user who chooses a {{FederatedCredential}} whose origin supports
    BrowserID could perform the authentication steps in the background by
    passing the user's email address and public key to the relevant
    <a>identity provider</a>, and adding a new property to the
    {{FederatedCredential}} given back to the website which contains the
    signed certificate asserting the user's identity.

    This document doesn't specify any of that behavior, but is designed with
    it in mind: the immediate goal is to give websites more direct access to
    the user agent's existing credential manager, as federations are completely
    unsupported at the moment. Generating assertions is an obvious next step.
    See [[#future-work]] for other thoughts on the subject.

    <h4 id="existing-solutions-webid">WebID</h4>

    TODO
  </section>
</section>

<!--
████████  ████████ ████████ ████ ██    ██ ████ ████████ ████  ███████  ██    ██  ██████
██     ██ ██       ██        ██  ███   ██  ██     ██     ██  ██     ██ ███   ██ ██    ██
██     ██ ██       ██        ██  ████  ██  ██     ██     ██  ██     ██ ████  ██ ██
██     ██ ██████   ██████    ██  ██ ██ ██  ██     ██     ██  ██     ██ ██ ██ ██  ██████
██     ██ ██       ██        ██  ██  ████  ██     ██     ██  ██     ██ ██  ████       ██
██     ██ ██       ██        ██  ██   ███  ██     ██     ██  ██     ██ ██   ███ ██    ██
████████  ████████ ██       ████ ██    ██ ████    ██    ████  ███████  ██    ██  ██████
-->
<section>
  <h2 id="terms">Key Concepts and Terminology</h2>

  <h3 id="terms-defined-here">Terms defined by this specification</h3>
  <dl>
    <dt>
      <dfn export>Credentials</dfn>
    </dt>
    <dd>
      A user authenticates herself to an <a>origin</a> by submitting a set of
      <strong>credentials</strong>. This typically consists of either a
      username/password pair, or a pointer out to a <a>federated identity
      provider</a> which will authenticate the user on her behalf.
    </dd>

    <dt>
      <dfn export>Credential Store</dfn>
    </dt>
    <dd>
      A <strong>credential store</strong> is an opaque storage mechanism which
      offers a user agent the ability to save, retrieve, and modify
      {{Credential}} objects.

      The implementation is vendor-specific, and the interface provided is not
      exposed to the web.
    </dd>

    <dt>
      <dfn export local-lt="pending">Pending Credential</dfn>
    </dt>
    <dd>
      A <strong>pending credential</strong> is a {{Credential}} object created
      automatically by the user agent when it believes that a user has
      signed-into, signed-up for, or changed credential on a website. For
      example, a pending credential may be created as a result of a successful
      form submission which contained a text field and a password field.

      Pending credentials are created in a vendor-specific way, using
      vendor-specific heuristics. They are retained for a <a>browsing
      context</a>, and MAY be retained across navigations, even cross-origin
      navigations (consider <code>accounts.example.com</code> redirecting to
      <code>webmail.example.com</code> upon successful sign-in).
    </dd>

    <dt>
      <dfn export local-lt="IDP|identity provider">
        Federated Identity Provider
      </dfn>
    </dt>
    <dd>
      A <strong>federated identity provider</strong> is an entity which a
      website trusts to correctly authenticate a user, and which provides an
      API for that purpose. OAuth2 [[RFC6749]] is an example of such an API,
      used by a number of providers.
    </dd>
  </dl>

  <h3 id="terms-defined-by-reference">Terms defined by reference</h3>
  <dl>
    <dt><a>origin</a></dt>
    <dd>
      An origin defines the scope of authority or privilege under which a
      resource operates. It is defined in detail in the Origin specification.
      [[!RFC6454]]
    </dd>

    <dt><a>ASCII serialization of an origin</a></dt>
    <dd>
      This algorithm is defined in
      <a href="https://tools.ietf.org/html/rfc6454#section-6.2">Section 6.2</a>
      of the Origin specification. [[!RFC6454]]
    </dd>

    <dt><a><i lang="la">a priori</i> insecure origin</a></dt>
    <dt><a><i lang="la">a priori</i> insecure url</a></dt>
    <dd>
      These terms are defined in 
      <a href="https://w3c.github.io/webappsec/specs/mixedcontent/#terms">Section
      2 of the Mixed Content specification</a>. [[!MIX]]
    </dd>

    <dt><a>sufficiently secure context</a></dt>
    <dt><a>Is <code>Document</code> a sufficiently secure context?</a></dt>
    <dd>
      These terms are defined in 
      <a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/#terms">Section
      2 of the Requirements for Powerful Features specification</a>. [[!POWER]]
    </dd>

    <dt><dfn lt="JavaScript global environment|global environment">JavaScript global environment</dfn></dt>
    <dd>
      This term is defined in <a lt="JavaScript global environment" spec="HTML5">Section
      2.2.2</a> of the HTML5 specification. [[!HTML5]]
    </dd>

    <dt><dfn>fetch</dfn></dt>
    <dd>
      "fetching" is the process by which a user agent requests resources, and
      delivers responses. It is defined in detail in the Fetch living standard.
      [[!FETCH]]
    </dd>

    <dt><dfn>request</dfn></dt>
    <dd>
      These terms are defined in
      <a href="http://fetch.spec.whatwg.org/#requests">Section 2.2</a> of the
      Fetch living standard. [[!FETCH]]
    </dd>

    <dt><dfn>response</dfn></dt>
    <dt><dfn>network error</dfn></dt>
    <dd>
      These terms are defined in detail in
      <a href="http://fetch.spec.whatwg.org/#responses">Section 2.3</a> of the
      Fetch living standard. [[!FETCH]]
    </dd>

    <dt><dfn>registerable domain</dfn></dt>
    <dt><dfn>public suffix</dfn></dt>
    <dd>
      An <a>origin</a>'s <strong>public suffix</strong> is defined via the
      <a href="https://publicsuffix.org/">Public Suffix List</a>, and represents
      the portion of the domain that is controlled by a public or private
      registry (e.g. the public suffix of <code>https://www.example.com/</code>
      is ".com"). The <strong>registerable domain</strong> is the public suffix
      plus one additional label: the registerable domain of
      <code>https://www.example.com/</code> is "example.com". [[!PSL]]
    </dd>
  </dl>
</section>

<!--
████ ██    ██ ████████ ████████ ████████  ████████    ███     ██████  ████████  ██████
 ██  ███   ██    ██    ██       ██     ██ ██         ██ ██   ██    ██ ██       ██    ██
 ██  ████  ██    ██    ██       ██     ██ ██        ██   ██  ██       ██       ██
 ██  ██ ██ ██    ██    ██████   ████████  ██████   ██     ██ ██       ██████    ██████
 ██  ██  ████    ██    ██       ██   ██   ██       █████████ ██       ██             ██
 ██  ██   ███    ██    ██       ██    ██  ██       ██     ██ ██    ██ ██       ██    ██
████ ██    ██    ██    ████████ ██     ██ ██       ██     ██  ██████  ████████  ██████
-->
<section>
  <h2 id="interfaces">Interfaces</h2>

  <h3 id="interfaces-credential-types">Credential Types</h3>

  We define two types of credentials: <dfn>local credentials</dfn>, consisting
  of a username/password pair that can be used to sign directly into a site, and
  <dfn>federated credentials</dfn>, consisting of a username/federation pair that
  can kick off some federated sign-in process (via Facebook Login, Firefox
  Accounts, etc):

  <h4 id="interfaces-credential-types-credential"><code>Credential</code></h4>
  <pre class="idl">
    [NoInterfaceObject]
    interface Credential {
      readonly attribute DOMString id;
      readonly attribute DOMString name;
      readonly attribute DOMString avatarURL;
    };
  </pre>
  <dl dfn-for="Credential">
    <dt><dfn attribute>id</dfn></dt>
    <dd>The credential's identifier. This might be a username or email address, for instance.</dd>

    <dt><dfn attribute>name</dfn></dt>
    <dd>
      A name associated with the credential, intended as a human-understandable
      public name.
    </dd>

    <dt><dfn attribute>avatarURL</dfn></dt>
    <dd>
      A URL pointing to an avatar image for the user. This URL MUST NOT be an
      <a><i lang="la">a priori</i> insecure URL</a>.

      ISSUE: How do we make this responsive? Adopt [[MANIFEST]]'s icon syntax?
    </dd>

  </dl>

  All {{Credential}} objects have internal slots named
  <code><dfn attribute for="credential">[[origin]]</dfn></code> and
  <code><dfn attribute for="credential">[[requiresUserMediation]]</dfn></code>
  which store the <a>origin</a> for which the credential was saved, and whether
  the credential may be exposed to a website without user mediation. These
  properties are not directly exposed to the web.

  <h4 id="interfaces-credential-types-localcredential"><code>LocalCredential</code></h4>
  <pre class="idl">
    [Constructor(DOMString id, DOMString password, optional DOMString name, optional DOMString avatarURL)]
    interface LocalCredential : Credential {
      readonly attribute FormData formData;
    };
  </pre>
  <dl dfn-for="LocalCredential">
    <dt><dfn attribute>formData</dfn></dt>
    <dd>An <a href="http://mikewest.github.io/credentialmanagement/writeonly/#opaque-formdata">opaque FormData object</a>,
    containing two entries: one named <code>username</code>, the other named
    <code>password</code>.</dd>
  </dl>

  All {{LocalCredential}} objects have an internal slot named <code><dfn>[[password]]</dfn></code>
  which stores the credential's password. This property is not directly exposed
  to the web, but used to construct the <a attribute>formData</a> property that
  is exposed to the web.

  <h4 id="interfaces-credential-types-federatedcredential"><code>FederatedCredential</code></h4>
  <pre class="idl">
    [Constructor(DOMString id, DOMString federation, optional DOMString name, optional DOMString avatarURL)]
    interface FederatedCredential : Credential {
      readonly attribute DOMString federation;
    };
  </pre>
  <dl dfn-for="FederatedCredential">
    <dt><dfn attribute>federation</dfn></dt>
    <dd>
      The credential's federation. For details regarding valid formats, see
      [[#identifying-federations]]
    </dd>
  </dl>

  <h4 id="interfaces-credential-types-pendingcredential"><code>PendingCredential</code></h4>

  A {{PendingCredential}} has no properties, and acts as a placeholder for the
  vendor-specific process of transiently holding onto credentials after a form
  submission causes navigation. If such a credential has been stored, then
  <code>navigator.credentials.pending</code> will be a {{PendingCredential}}
  object. If not, it will be <code>undefined</code>. The {{PendingCredential}}
  may be passed to {{notifySignedIn()}} or {{notifyFailedSignIn()}} in order
  to clearly express the site's intentions to the user agent. See
  [[#examples-post-signin]] for an example.

  <pre class="idl">
    [NoInterfaceObject]
    interface PendingCredential : Credential {
    };
  </pre>

  <h3 id="interfaces-credential-manager">Credential Manager</h3>

  The credential manager hangs off of the {{Navigator}} object, and exposes
  methods to request credentials, and to notify the user agent when interesting
  events occur: successful sign in, failed sign in, and sign out.

  <pre class="idl">
    partial interface Navigator {
      readonly attribute CredentialsContainer credentials;
    };

    interface CredentialsContainer {
      Promise&lt;Credential?&gt; request(optional CredentialRequestOptions options);
      Promise&lt;any&gt; notifySignedIn(optional Credential successfulCredential);
      Promise&lt;any&gt; notifyFailedSignIn(optional Credential failedCredential);
      Promise&lt;any&gt; notifySignedOut();

      readonly attribute PendingCredential? pending;
    };
  </pre>
  <dl dfn-for="CredentialsContainer">
    <dt><dfn method>request()</dfn></dt>
    <dd>
      Request a credential from the credential manager. The user agent MUST
      execute the algorithm defined in [[#request-credential]] with
      <var>options</var> as an argument.
    </dd>
    <dt><dfn method>notifySignedIn()</dfn></dt>
    <dd>
      Notify the credential manager that the user has successfully signed-in
      using a credential. The user agent MUST execute the algorithm defined
      in [[#save-credential]] with <var>credential</var> as an argument.
    </dd>
    <dt><dfn method>notifyFailedSignIn()</dfn></dt>
    <dd>
      Notify the credential manager that the user has failed to sign-in
      using a credential. The user agent MUST execute the algorithm defined
      in #TODO with <var>credential</var> as an argument.
    </dd>
    <dt><dfn method>notifySignedOut()</dfn></dt>
    <dd>
      Notify the credential manager that the user is signing out. The user
      agent MUST execute the algorithm defined in
      [[#require-user-mediation-for-origin]] with the <a>origin</a> of the
      <a>JavaScript global environment</a> in which this method is called.
    </dd>
    <dt><dfn attribute>pending</dfn></dt>
    <dd>
      If the user agent has a <a>pending credential</a> for the current page,
      this attribute will hold a {{PendingCredential}} object which may be
      passed to {{notifySignedIn()}} or {{notifyFailedSignIn()}}. If not, this
      attribute will be <code>undefined</code>.
    </dd>
  </dl>

  ISSUE: We should support explicit sign-up via {{LocalCredential}}s with
  generated passwords. Perhaps something similar to iOS8's
  <code>SecCreateSharedWebCredentialPassword</code>.

  ISSUE: Should we add <code>notifyChange(optional Credential credential)</code>?
  The functionality is currently wrapped up in [[#save-credential]], but could
  be trivially pushed out into a separate API if that makes things more clear.

  <h3 id="interfaces-request-options">Request Options</h3>

  <pre class="idl">
    dictionary CredentialRequestOptions {
      boolean suppressUI = false;
      sequence&lt;DOMString&gt; federations;
    };
  </pre>
  <dl dfn-for="CredentialRequestOptions">
    <dt><dfn dict-member>suppressUI</dfn></dt>
    <dd>
      If <code>true</code>, the user agent will only attempt to provide a
      {{Credential}} without user interaction: if the user has explicitly
      opted-into always giving a particular site access to a particular set of
      credentials, they will be provided. If not, the promise will resolve with
      <code>undefined</code>. For processing details, see the algorithm defined
      in [[#request-credential]].
    </dd>
    <dt><dfn dict-member>federations</dfn></dt>
    <dd>
      An array of federation identifiers. For details regarding valid formats
      see [[#identifying-federations]]
    </dd>
  </dl>

  <h4 id="identifying-federations">Identifying Federations</h4>

  Every site should use the same identifier when referring to a specific
  <a>federated identity provider</a>. For example,
  <a href="https://developers.facebook.com/docs/facebook-login/v2.0">Facebook Login</a>
  shouldn't be "Facebook" and "Facebook Login" and "FB" and "FBL" and
  "Facebook.com" and so on. It should have a canonical identifier which everyone
  can make use of, as consistent identification makes it possible for user
  agents to be helpful.

  For consistency, federations passed into the APIs defined in this document
  (e.g. {{CredentialRequestOptions}}'s {{CredentialRequestOptions/federations}}
  array, or {{FederatedCredential}}'s {{FederatedCredential/federation}} property)
  MUST be identified by the <a>ASCII serialization</a> of the origin the provider
  uses for sign in. That is, Facebook would be represented by
  <code>https://www.facebook.com</code> and Google by
  <code>https://accounts.google.com</code>.

  The ASCII serialization of an origin does <em>not</em> include a trailing
  U+002F SOLIDUS ("<code>/</code>"), but user agents SHOULD accept them
  silently: <code>https://accounts.google.com/</code> is clearly intended to
  be the same as <code>https://accounts.google.com</code>.
</section>

<!--
   ███    ██        ██████    ███████  ████████  ████ ████████ ██     ██ ██     ██  ██████
  ██ ██   ██       ██    ██  ██     ██ ██     ██  ██     ██    ██     ██ ███   ███ ██    ██
 ██   ██  ██       ██        ██     ██ ██     ██  ██     ██    ██     ██ ████ ████ ██
██     ██ ██       ██   ████ ██     ██ ████████   ██     ██    █████████ ██ ███ ██  ██████
█████████ ██       ██    ██  ██     ██ ██   ██    ██     ██    ██     ██ ██     ██       ██
██     ██ ██       ██    ██  ██     ██ ██    ██   ██     ██    ██     ██ ██     ██ ██    ██
██     ██ ████████  ██████    ███████  ██     ██ ████    ██    ██     ██ ██     ██  ██████
-->
<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="request-credential">
    Request a <code>Credential</code> with <var>options</var>
  </h3>

  This algorithm accepts a {{CredentialRequestOptions}} <var>options</var>, and
  returns a <code>Promise</code> which resolves with either a single
  {{Credential}} object if one could be obtained, or with <code>undefined</code>
  if no credential was available (either because the user refused to share a
  credential with this page, or because no credentials were available, period).

  If called from an environment which is not a <a>sufficiently secure
  context</a>, or from somewhere other than a <a>top-level browsing context</a>,
  the <code>Promise</code> will be rejected with a <code>SecurityError</code>.

  <ol>
    <li>
      Let <var>promise</var> be a newly created <code>Promise</code> object.
    </li>
    <li>
      Return <var>promise</var>, and execute the remaining steps asynchronously.
    </li>
    <li>
      Let <var>settings</var> be the <a>incumbent settings object</a>.
    </li>
    <li>
      If <var>settings</var> does not have a <a>responsible document</a>, then
      reject <var>promise</var> with a <code>SecurityError</code>
      <strong>and</strong> terminate this algorithm.
    </li>
    <li>
      If <var>settings</var>' <a>responsible document</a> is not the <a>active
      document</a> in the <a>top-level browsing context</a>
      If <var>environment</var> is not a <a>top-level browsing context</a>,
    <li>
      If the result of executing the <a>Is Document a sufficiently secure
      context?</a> algorithm on <var>settings</var>' <a>responsible document</a>
      is <code>Insecure</code> then reject <var>promise</var> with a
      <code>SecurityError</code> <strong>and</strong> terminate this algorithm.
    
    </li>
    <li>
      Let <var>origin</var> be the <a>origin</a> of the <var>environment</var>.
    </li>
    <li>
      Let <var>credential</var> be the result of executing the algorithm
      defined in [[#request-credential-without-mediation]].
    </li>
    <li>
      If <var>credential</var> is not <code>null</code>, resolve
      <var>promise</var> with <var>credential</var> and terminate this
      algorithm.
    </li>
    <li>
      If <var>options</var> is <code>undefined</code>, or if <code>options</code>'
      {{suppressUI}} property is <code>false</code>, then:

      <ol>
        <li>
          If this algorithm would not be <a>allowed to show a popup</a>, then
          resolve <var>promise</var> with a <code>SecurityError</code> and
          terminate this algorithm.

          Note: This requirement only applies if we would show UI to the user.
          If she's elected to allow credentials to be provided without user
          mediation, and we can do so, then we don't require a user gesture
          for {{request()}}. Otherwise, we do, due to the considerations in
          [[#privacy-considerations]].
        </li>
        <li>
          Ask the user which {{Credential}} to share.

          Note: This behavior is vendor-specific. Guidelines for user agent
          behavior are presented in [[#user-mediation]].
        </li>
        <li>
          Let <var>credential</var> be the {{Credential}} the user chose, or
          <code>null</code> if the user chose not to share a credential with
          <var>origin</var>.
        </li>
        <li>
          If <var>credential</var> is not <code>null</code>:
         
          <ol>
            <li>
              Let <var>data</var> be a new <a interface>FormData</a>
              object.
            </li>
            <li>
              Let <var>username entry</var> be the result of
              <a href="https://xhr.spec.whatwg.org/#create-an-entry">creating
              an entry</a> named "username" with a value of
              <var>credential</var>'s {{Credential/id}} attribute.
            </li>
            <li>
              Let <var>password entry</var> be the result of
              <a href="https://xhr.spec.whatwg.org/#create-an-entry">creating
              an entry</a> named "password" with a value of
              <var>credential</var>'s <code><a>[[password]]</a></code> slot.
            </li>
            <li>
              Append <var>username entry</var> and <var>password entry</var>
              to <var>data</var>.
            </li>
            <li>
              Set <var>data</var>'s
              <a href="http://mikewest.github.io/credentialmanagement/writeonly/#opaque-flag">opaque
              flag</a> to <code>true</code>.
            </li>
            <li>
              Set <var>credential</var>'s <a attribute>formData</a> attribute to
              <var>data</var>.
            </li>
            <li>
              Resolve <var>promise</var> with <var>credential</var> and
              terminate this algorithm.
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li>
      No {{Credential}} is available: terminate this algorithm by resolving
      <var>promise</var>.
    </li>
  </ol>

  <h3 id="request-credential-without-mediation">
    Request a <code>Credential</code> for <var>origin</var> with
    <var>options</var> <em>without</em> user mediation
  </h3>

  This algorithm accepts an <a>origin</a> <var>origin</var> and a
  {{CredentialRequestOptions}} <var>options</var>, and returns either a single
  {{Credential}} object if one can be provided without user mediation, or
  <code>null</code> if not.

  <ol>
    <li>
      If the user agent has disabled sharing credentials without user
      mediation, return <code>null</code>.

      Note: See [[#user-mediation-requirements]] for details.
    </li>
    <li>
      Let <var>credentials</var> be the set of {{Credential}} objects in the
      <a>credential store</a> whose {{[[origin]]}} slot is equal to the <a>ASCII
      serialization</a> of <var>origin</var>, and whose
      {{[[requiresUserMediation]]}} slot is <code>false</code>.

      Note: This is an exact match, not a <a>registerable domain</a> match.
      See [[#security-cross-origin-leakage]] for details as to why.
    </li>
    <li>
      If <var>credentials</var> is empty, or contains more than one
      {{Credential}} object, return <code>null</code>.

      Note: In the future, we may wish to allow multiple {{Credential}} objects
      to be returned; for the moment, we're erring on the cautious side to avoid
      accidentally revealing explicit relationships between user accounts.
    </li>
    <li>
      Otherwise, let <var>credential</var> be the single {{Credential}} object
      in <var>credentials</var>.
    </li>
    <li>
      If <var>credential</var> is a <code>FederatedCredential</code>, and
      the value of <var>credential</var>'s {{FederatedCredential/federation}}
      attribute does not appear in <var>options</var>'
      {{CredentialRequestOptions/federations}} array, return <code>null</code>.
    </li>
    <li>
      Return <var>credential</var>.
    </li>
  </ol>

  Note: If a user agent implements some sort of "private browsing" mode, we
  recommend that this algorithm always return <code>null</code> when the user
  has enabled private browsing.

  <h3 id="save-credential">
    Save <var>credential</var>
  </h3>

  This algorithm accepts a {{Credential}} <var>credential</var>, and hands it
  to the internal credential manager for processing. It returns a
  <code>Promise</code> which resolves with no arguments once credential is
  successfully persisted to the credential manager, or when the user rejects
  storage:

  <ol>
    <li>
      Let <var>promise</var> be a newly created <code>Promise</code> object.
    </li>
    <li>
      Return <var>promise</var>, and execute the remaining steps asynchronously.
    </li>
    <li>
      Let <var>environment</var> be the <a>JavaScript global environment</a> in
      which which this algorithm is executing.
    </li>
    <li>
      If <var>environment</var> is not a <a>top-level browsing context</a>,
      or <var>environment</var> is a <a>sufficiently secure context</a>, then
      reject <var>promise</var> with a <code>SecurityError</code>
      <strong>and</strong> terminate this algorithm.
    </li>
    <li>
      Let <var>origin</var> be the <a>origin</a> of the <var>environment</var>.
    </li>
    <li>
      If <var>credential</var> is a {{PendingCredential}}:

      <ol>
        <li>
          If the user agent has stored a <a>pending credential</a>, then set
          <var>credential</var> to that {{Credential}}.
        </li>
        <li>
          Otherwise, reject <var>Promise</var> with
          <code>InvalidStateError</code> and terminate this algorithm.
        </li>
      </ol>
    </li>
    <li>
      Set <var>credential</var>'s {{[[requiresUserMediation]]}} slot to
      <code>true</code>.
    </li>
    <li>
      Set <var>credential</var>'s {{[[origin]]}} slot to the <a>ASCII
      serialization</a> of <var>origin</var>.
    </li>
    <li>
      If <var>credential</var>'s {{Credential/avatarURL}} is an
      <a><i lang="la">a priori</i> insecure URL</a>, reject <var>promise</var>
      with a <code>SecurityError</code> and terminate this algorithm.
    </li>
    <li>
      If <var>credential</var> is a {{LocalCredential}}, then:

      <ol>
        <li>
          If the user agent's credential manager contains a {{LocalCredential}}
          <var>storedCredential</var> whose {{Credential/name}} attribute is
          <var>credential</var>'s {{Credential/name}} and whose
          {{[[origin]]}} slot is <var>origin</var>, then:

          <ol>
            <li>
              If the user grants <var>origin</var> permission to update
              credentials (as discussed in [[#user-mediated-storage]]), then:

              <ol>
                <li>
                  Set <var>storedCredential</var>'s
                  <code><a>[[password]]</a></code> to the value of
                  <var>credential</var>'s <code><a>[[password]]</a></code>
                  slot.
                </li>
                <li>
                  Set <var>storedCredential</var>'s {{Credential/name}} to the
                  value of <var>credential</var>'s {{Credential/name}}.
                </li>
                <li>
                  Set <var>storedCredential</var>'s {{Credential/avatarURL}} to
                  the value of <var>credential</var>'s {{Credential/avatarURL}}.
                </li>
              </ol>
            </li>
            <li>
              Resolve <var>promise</var>.
            </li>
          </ol>
        </li>
        <li>
          Otherwise:

          <ol>
            <li>
              If the user grants <var>origin</var> permission to store
              credentials (as discussed in [[#user-mediated-storage]]), then
              store <var>credential</var> in the <a>credential store</a>.
            </li>
            <li>
              Resolve <var>promise</var> and execute the remaining steps
              asynchronously.
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li>
      Otherwise, <var>credential</var> is a {{FederatedCredential}}:

      <ol>
        <li>
          If the user agent's credential manager contains a
          {{FederatedCredential}} <var>storedCredential</var> whose
          {{Credential/name}} attribute is <var>credential</var>'s
          {{Credential/name}} and whose {{FederatedCredential/federation}}
          attribute is <var>credential</var>'s
          {{FederatedCredential/federation}}, then resolve <var>promise</var>.
        </li>
        <li>
          Otherwise:

          <ol>
            <li>
              If the user grants <var>origin</var> permission to store
              credentials (as discussed in [[#user-mediated-storage]]), then
              store <var>credential</var> in the <a>credential store</a>.
            </li>
            <li>
              Resolve <var>promise</var> and execute the remaining steps
              asynchronously.
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <h3 id="require-user-mediation-for-origin">
    Require user mediation for <var>origin</var>
  </h3>

  <ol>
    <li>
      Let <var>credentials</var> be the set of all {{Credential}} objects in
      the <a>credential store</a> whose {{[[origin]]}} is <var>origin</var>.
    </li>
    <li>
      For each <var>credential</var> in <var>credentials</var>:

      <ol>
        <li>
          Set <var>credential</var>'s {{[[requiresUserMediation]]}} slot to
          <code>false</code>.
      </ol>
    </li>
  </ol>
</section>

<!--
██     ██ ████████ ████████  ████    ███    ████████ ████  ███████  ██    ██
███   ███ ██       ██     ██  ██    ██ ██      ██     ██  ██     ██ ███   ██
████ ████ ██       ██     ██  ██   ██   ██     ██     ██  ██     ██ ████  ██
██ ███ ██ ██████   ██     ██  ██  ██     ██    ██     ██  ██     ██ ██ ██ ██
██     ██ ██       ██     ██  ██  █████████    ██     ██  ██     ██ ██  ████
██     ██ ██       ██     ██  ██  ██     ██    ██     ██  ██     ██ ██   ███
██     ██ ████████ ████████  ████ ██     ██    ██    ████  ███████  ██    ██
-->
<section>
  <h2 id="user-mediation">User Mediation</h2>

  Exposing credential information to the web via an API has a number of
  potential impacts on user privacy. The user agent, therefore, MUST
  involve the user in a number of cases in order to ensure that she clearly
  understands what's going on, and with whom her credentials are being shared.

  <h3 id="user-mediated-storage">Storing and Updating Credentials</h3>

  Credential information is sensitive data, and users MUST remain in control
  of that information's storage. Inadvertent credential storage could, for
  instance, unexpectedly link a user's local profile on a particular device to
  a specific online persona. To mitigate the risk of surprise:

  <ol>
    <li>
      Credential information MUST NOT be stored or updated without explicit
      user consent. For example, the user agent could display a "Save this
      password?" dialog box to the user in response to each call to
      {{notifySignedIn()}}.
    </li>
    <li>
      User consent MAY be requested every time a credential is stored or
      updated, <strong>or</strong> the user agent MAY request a more persistent
      grant of consent which would apply to some or all subsequent API
      operations.

      For example, a user agent may offer an option to "Always save passwords",
      or "Always save password on this site".
    </li>
    <li>
      User agents SHOULD notify users when credentials are stored. This might
      take the form of an icon in the address bar, or some similar location.
    </li>
    <li>
      User agents MUST allow users to manually remove stored credentials. This
      functionality might be implemented as a settings page, or via interaction
      with a notification as described above.
    </li>
  </ol>

  <h3 id="user-mediation-requirements">Requiring User Mediation</h3>

  If a {{Credential}}'s {{[[requiresUserMediation]]}} slot is <code>false</code>,
  it will be provided to pages matching its {{[[origin]]}} without user
  interaction. The user will be signed-in to that origin persistently, which,
  on the one hand, is desirable from the perspective of usability and
  convinience, but which might nevertheless surprise the user.

  If the user agent syncs the state of a {{Credential}} between devices, an
  origin could explicitly tie the devices together in a way which might surprise
  their owner.

  To mitigate the risk of surprise:

  <ol>
    <li>
      User agents MUST allow users to require user mediation for {{Credential}}
      objects. This functionality might be implemented as a global toggle that
      requires user mediation for all origins, or via more granular settings
      for specific origins (or specific credentials on specific origins). 
    </li>
    <li>
      User agents MUST NOT set the {{[[requiresUserMediation]]}} slot's value
      to <code>false</code> without user consent. For example, the
      <a>credential chooser</a> described in [[#user-mediated-selection]] could
      have a checkbox which the user could toggle to mark the selected
      credential as available without mediation for the origin, or the user
      agent could have an onboarding process for its credential manager which
      asked a user for a default setting.
    </li>
    <li>
      User agents MUST notify users when credentials are provided to an
      origin. This could take the form of an icon in the address bar, or some
      similar location.
    </li>
    <li>
      If a user clears her browsing data for an origin (cookies, localStorage,
      and so on), the user agent MUST require user mediation for that origin
      by executing the algorithm defined in
      [[#require-user-mediation-for-origin]].
    </li>
  </ol>

  <h3 id="user-mediated-selection">Credential Selection</h3>

  When responding to a call to {{request()}} on an origin without credentials
  that are available without user mediation, user agents MUST ask the user for
  permission to share credential information. This SHOULD take the form of a
  <dfn local-lt="chooser">credential chooser</dfn> which presents the user
  with a list of credentials that are available for use on a site, allowing her
  to select one which should be provided to the website, or to reject the
  request entirely.

  The chooser interface SHOULD be implemented in such a way as to be
  distinguishable from UI which a website could produce. For example, the
  chooser might overlap the user agent's UI in some unspoofable way.

  The chooser interface SHOULD include an indication of the origin which is
  requesting credentials.

  The chooser interface SHOULD include all {{Credential}} objects associated
  with the origin that requested credentials. It MAY also include credentials
  associated with <a>federated identity providers</a> which the origin supports.
  For example, a credential associated with
  <code>https://www.facebook.com</code> might be suggested as a
  {{FederatedCredential}} on <code>https://example.com</code> if the latter
  lists the former as an accepted identity provider.

  Note: The credentials suggested in the chooser are not exposed to the web
  unless the user explicitly allows it. The user agent is therefore free to
  synthesize {{FederatedCredential}} objects for use in the chooser without
  risking a user's privacy.

  <em>The following image is an exceptionally non-normative mock:</em>

  <img src="./mock-chooser.png" alt="A mockup of what a chooser might look like.">

  User agents MAY internally associate information with each {{Credential}}
  object beyond the attributes specified in this document in order to enhance
  the utility of such a chooser. For example, favicons could help disambiguate
  identity providers, etc. Any additional information stored MUST not be
  exposed directly to the web.
</section>

<!--
 ██████  ████████  ██████  ██     ██ ████████  ████ ████████ ██    ██
██    ██ ██       ██    ██ ██     ██ ██     ██  ██     ██     ██  ██
██       ██       ██       ██     ██ ██     ██  ██     ██      ████
 ██████  ██████   ██       ██     ██ ████████   ██     ██       ██
      ██ ██       ██       ██     ██ ██   ██    ██     ██       ██
██    ██ ██       ██    ██ ██     ██ ██    ██   ██     ██       ██
 ██████  ████████  ██████   ███████  ██     ██ ████    ██       ██
-->
<section>
  <h2 id="security-considerations">Security Considerations</h2>

  <h3 id="security-cross-origin-leakage">Cross-origin Credential Leakage</h3>

  Credentials are sensitive information, and user agents need to exercise
  caution in determining when they can be safely shared with a website. The
  safest option is to restrict credential sharing to the exact origin on
  which they were saved. That is likely too restrictive for the web, however:
  consider sites which divide functionality into subdomains:
  <code>example.com</code> vs <code>admin.example.com</code>.

  As a compromise between annoying users, and securing their credentials, user
  agents:

  <ol>
    <li>
      MUST NOT share credentials between origins whose scheme components are
      not the same. That is: credentials saved on
      <code>https://example.com/</code> will never be available to
      <code>http://example.com/</code> via {{request()}}
    </li>
    <li>
      MAY use the Public Suffix List [[!PSL]] to determine the effective scope
      of a credential by comparing the <a>registerable domains</a> of the
      credential's <code>[[origin]]</code> with the origin in which
      {{request()}} is called. That is: credentials saved on
      <code>https://admin.example.com/</code> and
      <code>https://example.com/</code> MAY be offered to users when
      {{request()}} is called from <code>https://www.example.com/</code>
    </li>
    <li>
      MUST NOT offer credentials to an origin in response to {{request()}}
      without user mediation if the credential's origin is not an exact match
      for the calling origin. That is, {{Credential}} objects for
      <code>https://example.com</code> would not be returned directly to
      <code>https://www.example.com</code>, but could be offered to the user
      via the chooser.
    </li>
  </ol>

  Additionally, authors SHOULD mitigate the risk of leakage by setting a
  reasonable Content Security Policy [[!CSP]] which restricts the origins to
  which {{FormData!!interface}} objects can be sent. In particular, authors should
  ensure that the following directives are set, explicitly or implicitly, in
  their pages' policies:
 
  <ol>
    <li>
      <code><a>connect-src</a></code> restricts the origins to which
      {{FormData!!interface}} objects may be sent via {{XMLHttpRequest()}} and
      {{fetch()}.
    </li>
    <li>
      <code><a>form-action</a></code> restricts the origins to which
      {{FormData!!interface}} objects may be sent via form submissions.
    </li>
    <li>
      <code><a>frame-src</a></code> restricts the nested browsing
      contexts which may be embedded in a page, making it more difficult to
      inject a malicious {{postMessage()}} target. [[WEBMESSAGING]]
    </li>
  </ol>

  <h3 id="security-origin-confusion">Origin Confusion</h3>

  If framed pages have access to the APIs defined here, it might be possible
  to confuse a user into granting access to credentials for an origin other
  than the <a>top-level browsing context</a>, which is the only security origin
  which users can reasonably be expected to understand.

  Therefore, <a>Nested browsing contexts</a> and other <a>JavaScript global
  environments</a> like Workers [[WORKERS]] cannot receive or store
  {{Credential}} objects; the user agent MUST reject promises generated by
  calls to {{request()}} and {{notifySignedIn()}} with a
  <code>SecurityError</code> when called from a context which is not a
  <a>top-level browsing context</a>.

  See the algorithms defined in [[#request-credential]] and [[#save-credential]]
  for details.

  ISSUE: Is this a meaningful restriction for Service Workers? Probably not.

  <h3 id="security-insecure-origins">Insecure Sites</h3>

  User agents MUST NOT expose credential information via the APIs defined here
  to environments which are not <a>sufficiently secure contexts</a>. User agents
  MAY implement autofill mechanisms which store user credentials and fill
  sign-in forms on <a><i lang="la">a priori</i> insecure origins</a>, but those
  sites cannot be trusted to interact directly with the credential manager in
  any meaningful way.

  <h3 id="security-autocomplete-off">
    Reintroducing <code>autocomplete="off"</code>
  </h3>

  Some user agents have decided not to implement the
  <a element-attr>autocomplete</a></code> attribute in such a way as to
  prevent users from saving credentials. The APIs defined here SHOULD be
  implemented such that they don't provide an automatic way of bypassing that
  decision. Some of the requirements in [[#user-mediated-storage]] are in place
  for exactly this reason.
</section>

<section>
  <h2 id="privacy-considerations">Privacy Considerations</h2>

  <h3 id="privacy-timing-attacks">Timing Attacks</h3>

  If the user has no credentials for an origin, a call to {{request()}} will
  resolve very quickly indeed. A malicious website could distinguish between
  a user with no credentials and a user with credentials who chooses not to
  share them.

  This could allow a malicious website to determine if a user has credentials
  saved for particular federated identity providers by repeatedly calling
  {{request()}} with a single item in the
  {{CredentialRequestOptions/federations}} array. The risk is mitigated by the
  fact that a user-mediated {{request()}} is tied to a user gesture, and the
  user would, sooner or later, be prompted to provide credentials to the site,
  which would certainly raise her suspicions as to its behavior.


  <h3 id="privacy-chooser-leakage">Chooser Leakage</h3>

  If a user agent displayes images supplied by a website or federation (for
  example, if a {{Credential}}'s {{Credential/avatarURL}} is displayed),
  requests for these images MUST NOT be directly tied to instantiating the
  chooser in order to avoid leaking chooser usage. One option would be to fetch
  the images in the background when saving or updating a {{Credential}}, and to
  cache them for the lifetime of the {{Credential}}.
</section>

<!--
████ ██     ██ ████████  ██       ████████ ██     ██ ████████ ██    ██ ████████    ███    ████████ ████  ███████  ██    ██
 ██  ███   ███ ██     ██ ██       ██       ███   ███ ██       ███   ██    ██      ██ ██      ██     ██  ██     ██ ███   ██
 ██  ████ ████ ██     ██ ██       ██       ████ ████ ██       ████  ██    ██     ██   ██     ██     ██  ██     ██ ████  ██
 ██  ██ ███ ██ ████████  ██       ██████   ██ ███ ██ ██████   ██ ██ ██    ██    ██     ██    ██     ██  ██     ██ ██ ██ ██
 ██  ██     ██ ██        ██       ██       ██     ██ ██       ██  ████    ██    █████████    ██     ██  ██     ██ ██  ████
 ██  ██     ██ ██        ██       ██       ██     ██ ██       ██   ███    ██    ██     ██    ██     ██  ██     ██ ██   ███
████ ██     ██ ██        ████████ ████████ ██     ██ ████████ ██    ██    ██    ██     ██    ██    ████  ███████  ██    ██
-->
<section>
  <h2 id="implementation-considerations">Implementation Considerations</h2>

  <h3 id="implementation-for-authors">Website Authors</h3>

  <em>This section is non-normative.</em>

  ISSUE: Add some thoughts here about when and how the API should be used,
  especially with regard to {{suppressUI}}.
</section>

<!--
████████ ██     ██ ████████ ██     ██ ████████  ████████
██       ██     ██    ██    ██     ██ ██     ██ ██
██       ██     ██    ██    ██     ██ ██     ██ ██
██████   ██     ██    ██    ██     ██ ████████  ██████
██       ██     ██    ██    ██     ██ ██   ██   ██
██       ██     ██    ██    ██     ██ ██    ██  ██
██        ███████     ██     ███████  ██     ██ ████████
-->
<section>
  <h2 id="future-work">Future Work</h2>

  <em>This section is non-normative.</em>

  The API defined here does the bare minimum to expose user agent's credential
  managers to the web, and allows the web to help those credential managers
  understand when <a>federated identity providers</a> are in use. The next
  logical step will be along the lines sketched in documents like [[WEB-LOGIN]]
  (and, to some extent, Mozilla's BrowserID [[BROWSERID]]).

  The user agent is in the unique position of being able to effectively mediate
  the relationship between users, identity providers, and websites. If the user
  agent can remove some of the risk and confusion associated with the typical
  authentication flows, users will be in a significantly better position than
  today.

  The natural way to expose this information is to extend the
  {{FederatedCredential}} interface with properties like authentication tokens,
  and to add some form of manifest format with properties that declare the
  authentication type which the provider supports.

  Baby steps.
</section>
